import os
import cv2
import numpy as np
import shutil
import json

# Path configuration
BASE_INPUT_FOLDER = r"C:\xampp\htdocs\CIPHER\cipher i\bouncestream\chart\fetched"
BASE_OUTPUT_FOLDER = r"C:\xampp\htdocs\CIPHER\cipher i\bouncestream\chart\processing"
MARKET_NAME = "Drift Switch Index 30"

# Dynamically construct INPUT_FOLDER and OUTPUT_FOLDER with market name
MARKET_FOLDER_NAME = MARKET_NAME.replace(" ", "_")
INPUT_FOLDER = os.path.join(BASE_INPUT_FOLDER, MARKET_FOLDER_NAME)
OUTPUT_FOLDER = os.path.join(BASE_OUTPUT_FOLDER, MARKET_FOLDER_NAME)

def clear_output_folder():
    """Clear all files and subfolders in the BASE_OUTPUT_FOLDER."""
    try:
        if os.path.exists(BASE_OUTPUT_FOLDER):
            # Iterate through all items in the output folder
            for item in os.listdir(BASE_OUTPUT_FOLDER):
                item_path = os.path.join(BASE_OUTPUT_FOLDER, item)
                try:
                    if os.path.isfile(item_path):
                        os.remove(item_path)
                        print(f"Deleted file: {item_path}")
                    elif os.path.isdir(item_path):
                        shutil.rmtree(item_path)
                        print(f"Deleted folder: {item_path}")
                except Exception as e:
                    print(f"Error deleting {item_path}: {e}")
        else:
            print(f"Output folder does not exist: {BASE_OUTPUT_FOLDER}")
    except Exception as e:
        print(f"Error clearing output folder {BASE_OUTPUT_FOLDER}: {e}")

def load_latest_chart():
    """Find and load the latest chart image containing MARKET_NAME in the market-specific folder."""
    # Ensure the input folder exists
    if not os.path.exists(INPUT_FOLDER):
        print(f"Input folder does not exist: {INPUT_FOLDER}")
        return None, None
    
    # Search for files containing the market name (case-insensitive)
    files = [
        os.path.join(INPUT_FOLDER, f) for f in os.listdir(INPUT_FOLDER)
        if os.path.isfile(os.path.join(INPUT_FOLDER, f)) and 
           MARKET_NAME.replace(" ", "").lower() in f.replace(" ", "").lower()
    ]
    
    if not files:
        print(f"No files found containing '{MARKET_NAME}' in {INPUT_FOLDER}")
        return None, None
    
    # Find the latest file based on modification time
    chart_path = max(files, key=os.path.getmtime)
    print(f"Latest chart file found: {chart_path}")
    
    # Load the image
    img = cv2.imread(chart_path)
    if img is None:
        raise ValueError(f"Failed to load image: {chart_path}")
    
    # Get the base name of the file (without extension)
    base_name = os.path.splitext(os.path.basename(chart_path))[0]
    return img, base_name

def crop_image(img, height, width):
    """Crop the image: 200px from left, 30px from bottom, 150px from right."""
    if height < 20 or width < 350:  # 350 = 200 (left) + 150 (right)
        raise ValueError(f"Image too small to crop (height: {height}, width: {width})")
    return img[0:height-20, 0:width-100]

def enhance_colors(img):
    """Convert to HSV and enhance saturation and brightness for red and green pixels."""
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
    red_lower1 = np.array([0, 20, 20])
    red_upper1 = np.array([15, 255, 255])
    red_lower2 = np.array([165, 20, 20])
    red_upper2 = np.array([180, 255, 255])
    green_lower = np.array([30, 20, 20])
    green_upper = np.array([100, 255, 255])
    
    mask_red1 = cv2.inRange(hsv, red_lower1, red_upper1)
    mask_red2 = cv2.inRange(hsv, red_lower2, red_upper2)
    mask_red = cv2.bitwise_or(mask_red1, mask_red2)
    mask_green = cv2.inRange(hsv, green_lower, green_upper)
    mask = cv2.bitwise_or(mask_red, mask_green)
    
    hsv = hsv.astype(np.float32)
    h, s, v = cv2.split(hsv)
    s[mask > 0] = np.clip(s[mask > 0] * 2.0, 0, 255)  # Boost saturation by 2x
    v[mask > 0] = np.clip(v[mask > 0] * 1.5, 0, 255)  # Boost brightness by 1.5x
    hsv_enhanced = cv2.merge([h, s, v]).astype(np.uint8)
    
    img_enhanced = cv2.cvtColor(hsv_enhanced, cv2.COLOR_HSV2BGR)
    return img_enhanced, mask_red, mask_green, mask

def replace_near_black_wicks(img_enhanced, mask_red, mask_green):
    """Replace near-black wick pixels with bold red/green."""
    near_black_mask = cv2.inRange(img_enhanced, (0, 0, 0), (50, 50, 50))
    red_proximity = cv2.dilate(mask_red, np.ones((3, 3), np.uint8), iterations=1)
    img_enhanced[np.logical_and(near_black_mask > 0, red_proximity > 0)] = [0, 0, 255]
    green_proximity = cv2.dilate(mask_green, np.ones((3, 3), np.uint8), iterations=1)
    img_enhanced[np.logical_and(near_black_mask > 0, green_proximity > 0)] = [0, 255, 0]
    return img_enhanced

def sharpen_image(img_enhanced):
    """Apply sharpening to make candlesticks and wicks bold."""
    kernel = np.array([[-1, -1, -1],
                       [-1, 10, -1],
                       [-1, -1, -1]])
    return cv2.filter2D(img_enhanced, -1, kernel)

def set_background_black(img_enhanced, mask):
    """Set the background to pure black."""
    background_mask = cv2.bitwise_not(mask)
    img_enhanced[background_mask > 0] = [0, 0, 0]
    return img_enhanced

def save_enhanced_image(img_enhanced, base_name):
    """Save the enhanced image."""
    debug_image_path = os.path.join(OUTPUT_FOLDER, f"{base_name}_enhanced.png")
    cv2.imwrite(debug_image_path, img_enhanced)
    print(f"Debug enhanced image saved to: {debug_image_path}")
    return debug_image_path

def remove_horizontal_lines(img_enhanced, mask_red, mask_green, width):
    """Remove horizontal lines from the image."""
    gray = cv2.cvtColor(img_enhanced, cv2.COLOR_BGR2GRAY)
    binary = cv2.threshold(gray, 1, 255, cv2.THRESH_BINARY)[1]
    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (int(width * 0.2), 1))
    horizontal_lines = cv2.morphologyEx(binary, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)
    
    contours, _ = cv2.findContours(horizontal_lines, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for contour in contours:
        x, y, w, h = cv2.boundingRect(contour)
        aspect_ratio = w / float(h)
        if w > width * 0.1 and aspect_ratio > 10 and h < 5:
            cv2.drawContours(img_enhanced, [contour], -1, (0, 0, 0), -1)
            cv2.drawContours(mask_red, [contour], -1, 0, -1)
            cv2.drawContours(mask_green, [contour], -1, 0, -1)
    
    mask = cv2.bitwise_or(mask_red, mask_green)
    return img_enhanced, mask_red, mask_green, mask

def detect_candlestick_contours(img_enhanced, mask_red, mask_green):
    """Detect and draw contours for red and green candlesticks, draw one white arrow per unique candlestick position pointing downward to the top with a vertical line to the image top, and collect arrow data for JSON output."""
    img_contours = img_enhanced.copy()
    height, width = img_contours.shape[:2]  # Get image dimensions
    contours_red, _ = cv2.findContours(mask_red, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    red_count = 0
    red_positions = []
    all_candlestick_positions = []

    # Process red candlesticks
    for contour in contours_red:
        if cv2.contourArea(contour) >= 0.01:
            red_count += 1
            x, y, w, h = cv2.boundingRect(contour)
            center_x = x + w // 2
            top_y = y
            bottom_y = y + h
            red_positions.append((center_x, top_y, bottom_y))
            all_candlestick_positions.append((center_x, top_y, bottom_y, 'red', contour))

    contours_green, _ = cv2.findContours(mask_green, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    green_count = 0
    green_positions = []

    # Process green candlesticks
    for contour in contours_green:
        if cv2.contourArea(contour) >= 0.01:
            green_count += 1
            x, y, w, h = cv2.boundingRect(contour)
            center_x = x + w // 2
            top_y = y
            bottom_y = y + h
            green_positions.append((center_x, top_y, bottom_y))
            all_candlestick_positions.append((center_x, top_y, bottom_y, 'green', contour))

    # Filter out duplicate positions (same center_x)
    unique_positions = []
    seen_x = {}
    for pos in sorted(all_candlestick_positions, key=lambda x: x[0]):  # Sort by x-coordinate
        center_x, top_y, bottom_y, color, contour = pos
        if center_x not in seen_x:
            seen_x[center_x] = pos
            unique_positions.append(pos)
        else:
            # If duplicate x-coordinate, keep the contour with larger area
            existing_pos = seen_x[center_x]
            existing_contour = existing_pos[4]
            if cv2.contourArea(contour) > cv2.contourArea(existing_contour):
                # Replace with the new position if it has a larger contour area
                unique_positions[unique_positions.index(existing_pos)] = pos
                seen_x[center_x] = pos

    # Draw contours and arrows for unique positions
    for center_x, top_y, bottom_y, color, contour in unique_positions:
        # Draw contour based on color
        contour_color = (255, 0, 0) if color == 'red' else (255, 255, 255)
        cv2.drawContours(img_contours, [contour], -1, contour_color, 1)

        # Draw white arrow pointing downward to the top of the candlestick
        arrow_start = (center_x, max(0, top_y - 30))  # Start 30 pixels above the top
        arrow_end = (center_x, top_y)  # End at the top of the candlestick
        cv2.arrowedLine(img_contours, arrow_start, arrow_end, (255, 255, 255), 1, tipLength=0.3)

        # Draw vertical line from arrowhead to the top of the image
        cv2.line(img_contours, arrow_end, (center_x, 0), (255, 255, 255), 1)

    # Create arrow data for JSON, numbering from right to left, excluding the rightmost candlestick
    arrow_data = []
    arrow_count = 0
    for i, (center_x, top_y, bottom_y, color, _) in enumerate(reversed(unique_positions[:-1]), 1):  # Exclude rightmost
        arrow_count += 1
        arrow_data.append({
            "arrow_number": i,
            "pointing_on_candle_color": color,
            "x": center_x
        })

    print(f"Red candlesticks detected: {red_count}")
    print(f"Green candlesticks detected: {green_count}")
    print(f"Total candlesticks detected: {red_count + green_count}")
    print(f"Unique candlestick positions: {len(unique_positions)}")
    print(f"Total arrows: {arrow_count}")

    return img_contours, red_positions, green_positions, arrow_data

def save_arrow_data_to_json(arrow_data):
    """
    Save the arrow data to a JSON file named after the market in the OUTPUT_FOLDER.
    
    Args:
        arrow_data (list): List of dictionaries containing arrow details.
    
    Returns:
        str: Path to the saved JSON file.
    """
    json_path = os.path.join(OUTPUT_FOLDER, f"{MARKET_FOLDER_NAME}_arrows.json")
    try:
        with open(json_path, 'w') as f:
            json.dump(arrow_data, f, indent=4)
        print(f"Arrow data saved to: {json_path}")
    except Exception as e:
        print(f"Error saving arrow data to JSON: {e}")
    return json_path

def save_contour_image(img_contours, base_name):
    """Save the contour image."""
    contour_image_path = os.path.join(OUTPUT_FOLDER, f"{base_name}_contours.png")
    cv2.imwrite(contour_image_path, img_contours)
    print(f"Original contour image saved to: {contour_image_path}")
    return contour_image_path

def connect_contours(img_contours, red_positions, green_positions):
    """Connect candlestick contours with lines based on high/low points."""
    img_connected_contours = img_contours.copy()
    all_positions = [(pos, 'red') for pos in red_positions] + [(pos, 'green') for pos in green_positions]
    all_positions.sort(key=lambda x: x[0][0])
    
    connection_points = []
    for i, (pos, color) in enumerate(all_positions):
        x, top_y, bottom_y = pos
        is_low = False
        is_high = False
        
        if i > 0 and i < len(all_positions) - 1:
            prev_bottom_y = all_positions[i-1][0][2]
            next_bottom_y = all_positions[i+1][0][2]
            if bottom_y > prev_bottom_y and bottom_y > next_bottom_y:
                is_low = True
            prev_top_y = all_positions[i-1][0][1]
            next_top_y = all_positions[i+1][0][1]
            if top_y < prev_top_y and top_y < next_top_y:
                is_high = True
        elif i == 0 and len(all_positions) > 1:
            next_bottom_y = all_positions[i+1][0][2]
            next_top_y = all_positions[i+1][0][1]
            if bottom_y > next_bottom_y:
                is_low = True
            if top_y < next_top_y:
                is_high = True
        elif i == len(all_positions) - 1 and len(all_positions) > 1:
            prev_bottom_y = all_positions[i-1][0][2]
            prev_top_y = all_positions[i-1][0][1]
            if bottom_y > prev_bottom_y:
                is_low = True
            if top_y < prev_top_y:
                is_high = True
        
        if is_low or is_high:
            connection_points.append((x, top_y, bottom_y, 'low' if is_low else 'high', color))
    
    connection_points.sort(key=lambda x: x[0])
    
    for i in range(len(connection_points) - 1):
        x1, top_y1, bottom_y1, type1, color1 = connection_points[i]
        x2, top_y2, bottom_y2, type2, color2 = connection_points[i + 1]
        
        y1 = top_y1 if type1 == 'high' else bottom_y1
        y2 = top_y2 if type2 == 'high' else bottom_y2
        cv2.line(img_connected_contours, (x1, y1), (x2, y2), (255, 255, 255), 1)
    
    return img_connected_contours, all_positions

def save_connected_contour_image(img_connected_contours, base_name):
    """Save the connected contour image."""
    connected_contour_image_path = os.path.join(OUTPUT_FOLDER, f"{base_name}_connected_contours.png")
    cv2.imwrite(connected_contour_image_path, img_connected_contours)
    print(f"Connected contour image saved to: {connected_contour_image_path}")
    return connected_contour_image_path


def identify_parent_highs_and_lows(img_enhanced, all_positions, base_name, left_required, right_required, arrow_data):
    """
    Identify and label Parent Highs (PH) and Parent Lows (PL) on the enhanced image using arrow numbers.
    A Parent Low (PL) has the lowest bottom y-coordinate compared to at least 'left_required' low(s) to its left
    and at least 'right_required' low(s) to its right, where all these lows have higher bottoms than the candidate.
    A Parent High (PH) has the highest top y-coordinate compared to at least 'left_required' high(s) to its left
    and at least 'right_required' high(s) to its right, where all these highs have lower tops than the candidate.
    
    Args:
        img_enhanced (numpy.ndarray): Enhanced image without any numbering.
        all_positions (list): List of tuples containing (position, color) for each candlestick,
                             where position is (x, top_y, bottom_y).
        base_name (str): Base name of the input file for saving the output.
        left_required (int): Number of highs/lows required to the left.
        right_required (int): Number of highs/lows required to the right.
        arrow_data (list): List of dictionaries containing arrow details (arrow_number, x).
    
    Returns:
        str: Path to the saved image with PL and PH labels.
    """
    # Create a copy of the input image to draw labels on
    img_parent_labeled = img_enhanced.copy()
    
    # Initialize lists to store low and high points
    low_points = []
    high_points = []
    total_candles = len(all_positions)
    
    # Create a mapping of x-coordinate to arrow number
    arrow_map = {item['x']: item['arrow_number'] for item in arrow_data}
    
    # Identify low and high points
    for i, (pos, color) in enumerate(reversed(all_positions[:-1]), 1):  # Exclude rightmost candlestick
        x, top_y, bottom_y = pos
        orig_index = total_candles - 1 - i  # Original index in all_positions (left-to-right)
        
        is_low = False
        is_high = False
        
        if orig_index > 0 and orig_index < total_candles - 1:
            prev_bottom_y = all_positions[orig_index + 1][0][2]  # Next candlestick (left)
            next_bottom_y = all_positions[orig_index - 1][0][2]  # Previous candlestick (right)
            if bottom_y > prev_bottom_y and bottom_y > next_bottom_y:
                is_low = True
            prev_top_y = all_positions[orig_index + 1][0][1]
            next_top_y = all_positions[orig_index - 1][0][1]
            if top_y < prev_top_y and top_y < next_top_y:
                is_high = True
        elif orig_index == 0 and total_candles > 2:  # Second candlestick from right
            next_bottom_y = all_positions[orig_index + 1][0][2]
            next_top_y = all_positions[orig_index + 1][0][1]
            if bottom_y > next_bottom_y:
                is_low = True
            if top_y < next_top_y:
                is_high = True
        elif orig_index == total_candles - 2 and total_candles > 2:  # Leftmost numbered candlestick
            prev_bottom_y = all_positions[orig_index - 1][0][2]
            prev_top_y = all_positions[orig_index - 1][0][1]
            if bottom_y > prev_bottom_y:
                is_low = True
            if top_y < prev_top_y:
                is_high = True
        
        if is_low:
            low_points.append((orig_index, x, bottom_y, i))
        if is_high:
            high_points.append((orig_index, x, top_y, i))
    
    # Sort points by x-coordinate (left to right)
    low_points.sort(key=lambda x: x[1])
    high_points.sort(key=lambda x: x[1])
    
    # Identify Parent Lows (PL)
    pl_count = 0
    pl_labels = []
    for i, (orig_index, x, bottom_y, number) in enumerate(low_points):
        left_count = 0
        right_count = 0
        is_lowest = True
        
        # Check left lows
        for j in range(i - 1, -1, -1):
            if low_points[j][2] < bottom_y:  # Left low is higher
                left_count += 1
                if left_count >= left_required:
                    break
            else:
                is_lowest = False
        
        # Check right lows
        for j in range(i + 1, len(low_points)):
            if low_points[j][2] < bottom_y:  # Right low is higher
                right_count += 1
                if right_count >= right_required:
                    break
            else:
                is_lowest = False
        
        # Label as PL if it has the lowest bottom among the checked points
        if left_count >= left_required and right_count >= right_required and is_lowest:
            pl_count += 1
            arrow_number = arrow_map.get(x, None)
            if arrow_number is not None:
                label = f"PL{arrow_number}"
                text_position = (x - 20, bottom_y + 20)  # Below the candlestick
                cv2.putText(img_parent_labeled, label, text_position, cv2.FONT_HERSHEY_SIMPLEX,
                            0.5, (255, 255, 255), 1, cv2.LINE_AA)
                pl_labels.append((x, bottom_y, label, arrow_number))
    
    # Identify Parent Highs (PH)
    ph_count = 0
    ph_labels = []
    for i, (orig_index, x, top_y, number) in enumerate(high_points):
        left_count = 0
        right_count = 0
        is_highest = True
        
        # Check left highs
        for j in range(i - 1, -1, -1):
            if high_points[j][2] > top_y:  # Left high is lower
                left_count += 1
                if left_count >= left_required:
                    break
            else:
                is_highest = False
        
        # Check right highs
        for j in range(i + 1, len(high_points)):
            if high_points[j][2] > top_y:  # Right high is lower
                right_count += 1
                if right_count >= right_required:
                    break
            else:
                is_highest = False
        
        # Label as PH if it has the highest top among the checked points
        if left_count >= left_required and right_count >= right_required and is_highest:
            ph_count += 1
            arrow_number = arrow_map.get(x, None)
            if arrow_number is not None:
                label = f"PH{arrow_number}"
                text_position = (x - 20, top_y - 10)  # Above the candlestick
                cv2.putText(img_parent_labeled, label, text_position, cv2.FONT_HERSHEY_SIMPLEX,
                            0.5, (255, 255, 255), 1, cv2.LINE_AA)
                ph_labels.append((x, top_y, label, arrow_number))
    
    # Print the number of PL and PH identified
    print(f"Identified {pl_count} Parent Lows (PL) with {left_required} left and {right_required} right lows required")
    print(f"Identified {ph_count} Parent Highs (PH) with {left_required} left and {right_required} right highs required")
    
    # Save the labeled image
    parent_labeled_image_path = os.path.join(OUTPUT_FOLDER, f"{base_name}_parent_highs_lows.png")
    cv2.imwrite(parent_labeled_image_path, img_parent_labeled)
    print(f"Parent highs and lows labeled image saved to: {parent_labeled_image_path}")
    
    return parent_labeled_image_path, pl_labels, ph_labels

def controlleftandrighthighsandlows(left, right):
    """
    Control the number of highs/lows required to the left and right for PH/PL identification.
    
    Args:
        left (str): Number of highs/lows required to the left (as a string, e.g., "1").
        right (str): Number of highs/lows required to the right (as a string, e.g., "1").
    
    Returns:
        tuple: (left_count_required, right_count_required) as integers.
    """
    try:
        left_count_required = int(left)
        right_count_required = int(right)
        if left_count_required < 0 or right_count_required < 0:
            raise ValueError("Left and right counts must be non-negative.")
        return left_count_required, right_count_required
    except ValueError as e:
        raise ValueError(f"Invalid input for left or right: {e}")


#DRAWING main_trendline 
def draw_parent_main_trendlines(img_parent_labeled, all_positions, base_name, left_required, right_required, 
                          main_trendline_position, distance_threshold, num_contracts, allow_latest_main_trendline,
                          pl_labels, ph_labels):
   
    img_main_trendlines = img_parent_labeled.copy()
    total_candles = len(all_positions)
    
    # Get image width for extending main_trendlines to the right edge
    img_width = img_main_trendlines.shape[1]
    
    # Font settings for position numbers and 's' labels
    font = cv2.FONT_HERSHEY_SIMPLEX
    font_scale = 0.5
    text_color = (255, 255, 255)  # White text
    thickness = 1
    line_type = cv2.LINE_AA
    
    # Draw position numbers for PL and PH
    for x, bottom_y, label, arrow_number in pl_labels:
        text_position = (x - 20, bottom_y + 35)  # 20px below PL label (PL is at bottom_y + 20)
        cv2.putText(img_main_trendlines, str(arrow_number), text_position, font,
                    font_scale, text_color, thickness, line_type)
    
    for x, top_y, label, arrow_number in ph_labels:
        text_position = (x - 20, top_y - 25)  # 10px above PH label (PH is at top_y - 10)
        cv2.putText(img_main_trendlines, str(arrow_number), text_position, font,
                    font_scale, text_color, thickness, line_type)
    
    # Sort all_positions by x-coordinate
    sorted_positions = sorted(all_positions, key=lambda x: x[0][0])
    
    # Track used points for PH-to-PL and PL-to-PH connections
    used_points_ph_to_pl = set()
    used_points_pl_to_ph = set()
    
    # Initialize list to store main_trendline data for JSON
    main_trendline_data = []
    
    # Initialize list to store parent distances for JSON
    parent_distances = []
    
    # Calculate PH-to-PH vertical distances
    ph_labels_sorted = sorted(ph_labels, key=lambda x: x[0])  # Sort by x-coordinate
    for i in range(len(ph_labels_sorted) - 1):
        x1, top_y1, label1, arrow_number1 = ph_labels_sorted[i]
        x2, top_y2, label2, arrow_number2 = ph_labels_sorted[i + 1]
        distance = abs(top_y1 - top_y2)
        parent_distances.append({
            "type": "PH-to-PH",
            "from_label": label1,
            "to_label": label2,
            "vertical_distance_px": distance
        })
        print(f"PH-to-PH distance from {label1} (x={x1}, y={top_y1}) to {label2} (x={x2}, y={top_y2}): {distance}px")
    
    # Calculate PL-to-PL vertical distances
    pl_labels_sorted = sorted(pl_labels, key=lambda x: x[0])  # Sort by x-coordinate
    for i in range(len(pl_labels_sorted) - 1):
        x1, bottom_y1, label1, arrow_number1 = pl_labels_sorted[i]
        x2, bottom_y2, label2, arrow_number2 = pl_labels_sorted[i + 1]
        distance = abs(bottom_y1 - bottom_y2)
        parent_distances.append({
            "type": "PL-to-PL",
            "from_label": label1,
            "to_label": label2,
            "vertical_distance_px": distance
        })
        print(f"PL-to-PL distance from {label1} (x={x1}, y={bottom_y1}) to {label2} (x={x2}, y={bottom_y2}): {distance}px")
    
    # Save parent distances to a separate JSON file
    parent_distances_json_path = os.path.join(OUTPUT_FOLDER, f"{base_name}_parent_distances.json")
    try:
        with open(parent_distances_json_path, 'w') as f:
            json.dump(parent_distances, f, indent=4)
        print(f"Parent distances saved to: {parent_distances_json_path}")
    except Exception as e:
        print(f"Error saving parent distances to JSON: {e}")
    
    # Helper function to find candlestick at specified position
    def get_candle_at_position(receiver_x, position):
        try:
            pos = int(position)
        except ValueError:
            pos = 1
        count = 0
        for pos_data, color in sorted_positions:
            if pos_data[0] > receiver_x:
                count += 1
                if count == pos:
                    return pos_data, color
        print(f"No candlestick found at position {position} to the right of x={receiver_x}")
        return None, None
    
    # Helper function to check if a main_trendline crosses another PH or PL
    def crosses_other_parent(start_x, end_x, start_y, end_y, points_to_check, exclude_labels=None):
        if exclude_labels is None:
            exclude_labels = set()
        for x, y, label, _ in points_to_check:
            if label in exclude_labels:
                continue
            if start_x < x < end_x:
                if start_x != end_x:
                    t = (x - start_x) / (end_x - start_x)
                    line_y = start_y + t * (end_y - start_y)
                    if abs(line_y - y) < 20:
                        return True, label
        return False, None
    
    # Helper function to extend line to the right edge of the image
    def extend_line_to_right_edge(start_x, start_y, target_x, target_y, img_width):
        if target_x == start_x:
            return img_width, start_y
        m = (target_y - start_y) / (target_x - start_x)
        c = start_y - m * start_x
        end_y = m * img_width + c
        return img_width, int(end_y)
    
    # Helper function to count parents ahead
    def count_parents_ahead(x, parent_points):
        return sum(1 for p in parent_points if p[0] > x)
    
    # Helper function to extract position number from label (e.g., PH3 -> 3, PL5 -> 5)
    def get_position_number_from_label(label):
        try:
            return int(label[2:])  # Extract number after "PH" or "PL"
        except ValueError:
            return None
    
    # Helper function to get position number for a candlestick
    def get_position_number(x, labels, all_positions):
        for px, _, label, _ in labels:
            if px == x:
                pos_number = get_position_number_from_label(label)
                if pos_number is not None:
                    return pos_number
        for i, (pos, _) in enumerate(reversed(all_positions[:-1]), 1):
            if pos[0] == x:
                return i
        return None
    
    # Helper function to get the next two parents after the receiver
    def get_next_two_parents(receiver_x, pl_labels, ph_labels, main_trendline_type):
        all_parents = [(x, 'PL', y) for x, y, _, _ in pl_labels] + [(x, 'PH', y) for x, y, _, _ in ph_labels]
        parents_to_right = sorted([(x, parent_type, y) for x, parent_type, y in all_parents if x > receiver_x], key=lambda p: p[0])
        if len(parents_to_right) >= 1:
            first_parent = parents_to_right[0][1]
            # Validate first parent based on main_trendline type
            if main_trendline_type == 'PH-to-PL' and first_parent != 'PH':
                first_parent = 'invalid'
            elif main_trendline_type == 'PL-to-PH' and first_parent != 'PL':
                first_parent = 'invalid'
        else:
            first_parent = 'invalid'
        if len(parents_to_right) >= 2:
            second_parent = parents_to_right[1][1]
            # Validate second parent based on main_trendline type
            if main_trendline_type == 'PH-to-PL' and second_parent != 'PH':
                second_parent = 'invalid'
            elif main_trendline_type == 'PL-to-PH' and second_parent != 'PL':
                second_parent = 'invalid'
        else:
            second_parent = 'invalid'
        return first_parent, second_parent
    
    # Helper function to find the candlestick that contains a parent (PL or PH) by x-coordinate
    def get_candle_for_parent(parent_x, all_positions):
        for pos, color in all_positions:
            if pos[0] == parent_x:
                return pos, color
        return None, None
    
    # Helper function to find the next PL or PH to the right
    def get_next_parent_position(receiver_x, pl_labels, ph_labels, main_trendline_type):
        all_parents = [(x, 'PL', y) for x, y, _, _ in pl_labels] + [(x, 'PH', y) for x, y, _, _ in ph_labels]
        parents_to_right = [(x, parent_type, y) for x, parent_type, y in all_parents if x > receiver_x]
        if not parents_to_right:
            return None, None, None
        # Filter parents based on main_trendline type
        valid_parent_type = 'PH' if main_trendline_type == 'PH-to-PL' else 'PL'
        valid_parents = [p for p in parents_to_right if p[1] == valid_parent_type]
        if not valid_parents:
            return None, None, None
        closest_parent = min(valid_parents, key=lambda p: p[0])
        return closest_parent[0], closest_parent[1], closest_parent[2]
    
    # Helper function to find the next candlestick touched by a horizontal line at y_level
    def get_next_candle_touched(receiver_x, y_level, sorted_positions, check_below=False, check_above=False):
        for pos_data, _ in sorted_positions:
            if pos_data[0] > receiver_x:
                if check_below and pos_data[2] > y_level:  # Bottom is below y_level
                    return pos_data[0]
                if check_above and pos_data[1] < y_level:  # Top is above y_level
                    return pos_data[0]
                if not (check_below or check_above) and pos_data[1] <= y_level <= pos_data[2]:  # Line intersects candlestick body
                    return pos_data[0]
        return None
    
    # Helper function to find the latest candlestick
    def get_latest_candle(sorted_positions):
        if sorted_positions:
            return sorted_positions[-1][0]  # Return the position tuple of the rightmost candlestick
        return None
    
    # PH to PL (top to top of the candlestick at specified position to the right of the nearest PL, green)
    for i, (x1, top_y1, label1, arrow_number1) in enumerate(ph_labels):
        if label1 in used_points_ph_to_pl:
            continue
        
        nearest_pl = None
        min_distance = float('inf')
        for j, (x2, bottom_y2, label2, arrow_number2) in enumerate(pl_labels):
            if x2 > x1 and label2 not in used_points_ph_to_pl:
                distance = x2 - x1
                if distance < min_distance:
                    min_distance = distance
                    nearest_pl = (x2, bottom_y2, label2, arrow_number2)
        
        if nearest_pl is None:
            print(f"No unused PL found to the right of {label1}, skipping connection")
            continue
        
        x2, bottom_y2, label2, arrow_number2 = nearest_pl
        
        if not allow_latest_main_trendline:
            ph_ahead_count = count_parents_ahead(x2, ph_labels)
            if ph_ahead_count == 0:
                print(f"No PH found ahead of {label2}, skipping PH-to-PL main_trendline from {label1}")
                continue
        
        next_candle, receiver_color = get_candle_at_position(x2, main_trendline_position)
        if next_candle is None:
            print(f"No candlestick found at position {main_trendline_position} to the right of {label2}, skipping connection")
            continue
        
        if next_candle[1] <= top_y1:
            print(f"Skipping PH-to-PL main_trendline from {label1} to candlestick at position {main_trendline_position} right of {label2} "
                  f"because receiver top (y={next_candle[1]}) is higher than or equal to sender top (y={top_y1})")
            continue
        
        vertical_distance = abs(top_y1 - next_candle[1])
        if vertical_distance < distance_threshold:
            print(f"Skipping PH-to-PL main_trendline from {label1} to candlestick at position {main_trendline_position} right of {label2} "
                  f"due to vertical distance {vertical_distance} < threshold {distance_threshold}")
            continue
        
        crosses, crossed_label = crosses_other_parent(
            x1, next_candle[0], top_y1, next_candle[1],
            pl_labels + ph_labels,
            exclude_labels={label1, label2}
        )
        if crosses:
            print(f"Skipping PH-to-PL main_trendline from {label1} to candlestick at position {main_trendline_position} right of {label2} "
                  f"due to crossing {crossed_label}")
            continue
        
        end_x, end_y = extend_line_to_right_edge(x1, top_y1, next_candle[0], next_candle[1], img_width)
        
        crosses, crossed_label = crosses_other_parent(
            next_candle[0], end_x, next_candle[1], end_y,
            pl_labels + ph_labels,
            exclude_labels={label1, label2}
        )
        if crosses:
            print(f"Skipping PH-to-PL main_trendline extension from {label1} to candlestick at position {main_trendline_position} right of {label2} "
                  f"due to crossing {crossed_label} in extension")
            continue
        
        sender_color = [color for pos, color in all_positions if pos[0] == x1][0]
        sender_pos_number = get_position_number_from_label(label1)
        receiver_pos_number = get_position_number(next_candle[0], pl_labels + ph_labels, all_positions)
        
        first_parent, second_parent = get_next_two_parents(x2, pl_labels, ph_labels, 'PH-to-PL')
        next_parent_label = first_parent
        
        # Initialize order_status and stoploss_status
        order_status = "none"
        stoploss_status = "none"
        
        # Create main_trendline data entry
        main_trendline_entry = {
            "type": "PH-to-PL",
            "sender": {
                "candle_color": sender_color,
                "position_number": sender_pos_number
            },
            "receiver": {
                "candle_color": receiver_color,
                "position_number": receiver_pos_number,
                "order_type": "long",
                "order_status": order_status,
                "stoploss_status": stoploss_status,
                "next_parent": next_parent_label,
                "receiver_arrow_number": arrow_number2
            }
        }
        main_trendline_data.append(main_trendline_entry)
        
        used_points_ph_to_pl.add(label1)
        used_points_ph_to_pl.add(label2)
    
    # PL to PH (bottom to bottom of the candlestick at specified position to the right of the nearest PH, yellow)
    for i, (x1, bottom_y1, label1, arrow_number1) in enumerate(pl_labels):
        if label1 in used_points_pl_to_ph:
            continue
        
        nearest_ph = None
        min_distance = float('inf')
        for j, (x2, top_y2, label2, arrow_number2) in enumerate(ph_labels):
            if x2 > x1 and label2 not in used_points_pl_to_ph:
                distance = x2 - x1
                if distance < min_distance:
                    min_distance = distance
                    nearest_ph = (x2, top_y2, label2, arrow_number2)
        
        if nearest_ph is None:
            print(f"No unused PH found to the right of {label1}, skipping connection")
            continue
        
        x2, top_y2, label2, arrow_number2 = nearest_ph
        
        if not allow_latest_main_trendline:
            pl_ahead_count = count_parents_ahead(x2, pl_labels)
            if pl_ahead_count == 0:
                print(f"No PL found ahead of {label2}, skipping PL-to-PH main_trendline from {label1}")
                continue
        
        next_candle, receiver_color = get_candle_at_position(x2, main_trendline_position)
        if next_candle is None:
            print(f"No candlestick at position {main_trendline_position} to the right of {label2}, skipping connection")
            continue
        
        if next_candle[2] >= bottom_y1:
            print(f"Skipping PL-to-PH main_trendline from {label1} to candlestick at position {main_trendline_position} right of {label2} "
                  f"because receiver bottom (y={next_candle[2]}) is lower than or equal to sender bottom (y={bottom_y1})")
            continue
        
        vertical_distance = abs(bottom_y1 - next_candle[2])
        if vertical_distance < distance_threshold:
            print(f"Skipping PL-to-PH main_trendline from {label1} to candlestick at position {main_trendline_position} right of {label2} "
                  f"due to vertical distance {vertical_distance} < threshold {distance_threshold}")
            continue
        
        crosses, crossed_label = crosses_other_parent(
            x1, next_candle[0], bottom_y1, next_candle[2],
            pl_labels + ph_labels,
            exclude_labels={label1, label2}
        )
        if crosses:
            print(f"Skipping PL-to-PH main_trendline from {label1} to candlestick at position {main_trendline_position} right of {label2} "
                  f"due to crossing {crossed_label}")
            continue
        
        end_x, end_y = extend_line_to_right_edge(x1, bottom_y1, next_candle[0], next_candle[2], img_width)
        
        crosses, crossed_label = crosses_other_parent(
            next_candle[0], end_x, next_candle[2], end_y,
            pl_labels + ph_labels,
            exclude_labels={label1, label2}
        )
        if crosses:
            print(f"Skipping PL-to-PH main_trendline extension from {label1} to candlestick at position {main_trendline_position} right of {label2} "
                  f"due to crossing {crossed_label} in extension")
            continue
        
        sender_color = [color for pos, color in all_positions if pos[0] == x1][0]
        sender_pos_number = get_position_number_from_label(label1)
        receiver_pos_number = get_position_number(next_candle[0], pl_labels + ph_labels, all_positions)
        
        first_parent, second_parent = get_next_two_parents(x2, pl_labels, ph_labels, 'PL-to-PH')
        next_parent_label = first_parent
        
        # Initialize order_status and stoploss_status
        order_status = "none"
        stoploss_status = "none"
        
        # Create main_trendline data entry
        main_trendline_entry = {
            "type": "PL-to-PH",
            "sender": {
                "candle_color": sender_color,
                "position_number": sender_pos_number
            },
            "receiver": {
                "candle_color": receiver_color,
                "position_number": receiver_pos_number,
                "order_type": "short",
                "order_status": order_status,
                "stoploss_status": stoploss_status,
                "next_parent": next_parent_label,
                "receiver_arrow_number": arrow_number2
            }
        }
        main_trendline_data.append(main_trendline_entry)
        
        used_points_pl_to_ph.add(label1)
        used_points_pl_to_ph.add(label2)
    
    # Sort main_trendlines by sender position number (left to right)
    main_trendline_data.sort(key=lambda x: x['sender']['position_number'])
    
    # Select the number of main_trendlines to draw (based on num_contracts, rightmost first)
    main_trendlines_to_draw = sorted(main_trendline_data, key=lambda x: x['receiver']['position_number'], reverse=True)[:num_contracts]
    print(f"Total valid main_trendlines: {len(main_trendline_data)}, drawing {min(num_contracts, len(main_trendline_data))} main_trendlines")
    
    # If num_contracts is 0, save the image with only position numbers (no main_trendlines or boxes)
    if num_contracts == 0:
        print("Number of contracts set to 0, only position numbers drawn")
        main_trendline_image_path = os.path.join(OUTPUT_FOLDER, f"{base_name}_parent_main_trendlines.png")
        cv2.imwrite(main_trendline_image_path, img_main_trendlines)
        print(f"Parent main_trendlines image saved to: {main_trendline_image_path}")
        return main_trendline_image_path, main_trendline_data
    
    # Draw selected main_trendlines, label CPs, draw boxes for receivers, and handle 's' label
    for main_trendline in main_trendlines_to_draw:
        # Draw the main_trendline (using coordinates from parent labels)
        sender_x = next((x for x, _, label, _ in (ph_labels if main_trendline['type'] == 'PH-to-PL' else pl_labels) if label == f"{main_trendline['type'].split('-')[0]}{main_trendline['sender']['position_number']}"), None)
        sender_y = next((y for x, y, label, _ in (ph_labels if main_trendline['type'] == 'PH-to-PL' else pl_labels) if label == f"{main_trendline['type'].split('-')[0]}{main_trendline['sender']['position_number']}"), None)
        receiver_x = next((x for x, _, label, _ in (pl_labels if main_trendline['type'] == 'PH-to-PL' else ph_labels) if label == f"{main_trendline['type'].split('-')[2]}{main_trendline['receiver']['receiver_arrow_number']}"), None)
        receiver_y = next((y for x, y, label, _ in (pl_labels if main_trendline['type'] == 'PH-to-PL' else ph_labels) if label == f"{main_trendline['type'].split('-')[2]}{main_trendline['receiver']['receiver_arrow_number']}"), None)
        
        if sender_x is None or sender_y is None or receiver_x is None or receiver_y is None:
            print(f"Skipping main_trendline drawing for {main_trendline['type']} due to missing coordinates")
            continue
        
        # Get receiver candlestick coordinates for CP
        receiver_candle, _ = get_candle_at_position(receiver_x, main_trendline_position)
        if receiver_candle is None:
            print(f"No candlestick found at position {main_trendline_position} for {main_trendline['type']}, skipping")
            continue
        
        start = (sender_x, sender_y)
        end = extend_line_to_right_edge(sender_x, sender_y, receiver_candle[0], receiver_candle[1 if main_trendline['type'] == 'PH-to-PL' else 2], img_width)
        color = (0, 255, 0) if main_trendline['type'] == 'PH-to-PL' else (0, 255, 255)  # Green or Yellow
        cv2.line(img_main_trendlines, start, end, color, 2)
        
        # Label CP and main_trendline type
        cp_y = receiver_candle[1 if main_trendline['type'] == 'PH-to-PL' else 2]
        text_position = (receiver_candle[0] - 40 if main_trendline['type'] == 'PH-to-PL' else receiver_candle[0] - 30, cp_y)
        cv2.putText(img_main_trendlines, 'CP', text_position, cv2.FONT_HERSHEY_SIMPLEX,
                    0.5, (255, 255, 255), 1, cv2.LINE_AA)
        
        type_label = 'PH&PL' if main_trendline['type'] == 'PH-to-PL' else 'PL&PH'
        type_position = (text_position[0], text_position[1] + 15)
        cv2.putText(img_main_trendlines, type_label, type_position, cv2.FONT_HERSHEY_SIMPLEX,
                    0.4, (255, 255, 255), 1, cv2.LINE_AA)
        
        # Get the candlestick corresponding to the receiver parent
        parent_candle, parent_color = get_candle_for_parent(receiver_x, all_positions)
        if parent_candle is None:
            print(f"No candlestick found for parent {main_trendline['type'].split('-')[2]}{main_trendline['receiver']['receiver_arrow_number']} at x={receiver_x}, skipping box and 's' label")
            continue
        
        # Initialize order_status and stoploss_status
        order_status = "none"
        stoploss_status = "none"
        
        # Determine box boundaries and order status
        if main_trendline['type'] == 'PH-to-PL':
            top_y = parent_candle[1]  # Top of PL candlestick
            bottom_y = parent_candle[2]  # Bottom of PL candlestick
            # Validate next parent for box drawing
            first_parent, second_parent = get_next_two_parents(receiver_x, pl_labels, ph_labels, 'PH-to-PL')
            valid_parent = False
            next_parent_x = None
            next_parent_type = None
            next_parent_y = None
            if first_parent == 'PH':
                valid_parent = True
                next_parent_x, next_parent_type, next_parent_y = get_next_parent_position(receiver_x, pl_labels, ph_labels, 'PH-to-PL')
            elif second_parent == 'PH':
                valid_parent = True
                # Find the second parent
                all_parents = [(x, parent_type, y) for x, parent_type, y in [(x, 'PL', y) for x, y, _, _ in pl_labels] + [(x, 'PH', y) for x, y, _, _ in ph_labels] if x > receiver_x]
                if len(all_parents) >= 2:
                    second_parent_data = sorted(all_parents, key=lambda p: p[0])[1]
                    next_parent_x, next_parent_type, next_parent_y = second_parent_data
            if valid_parent:
                # Check if the horizontal line at top_y touches a candlestick with lower bottom
                found = False
                box_end_x = min(receiver_x + 100, img_width)  # Default 100px box
                if next_parent_x is not None:
                    next_parent_candle, _ = get_candle_for_parent(next_parent_x, all_positions)
                    if next_parent_candle and next_parent_candle[2] > top_y:  # Bottom is lower (higher y)
                        box_end_x = next_parent_x
                        order_status = "executed"
                        found = True
                        print(f"Box will extend to {next_parent_type} at x={next_parent_x} for PL{main_trendline['receiver']['receiver_arrow_number']}")
                    else:
                        # Check candlesticks after the next valid PH
                        for pos_data, _ in sorted_positions:
                            if pos_data[0] > next_parent_x and pos_data[2] > top_y:  # Bottom is lower
                                box_end_x = pos_data[0]
                                order_status = "executed"
                                found = True
                                print(f"Box will extend to candlestick at x={pos_data[0]} for PL{main_trendline['receiver']['receiver_arrow_number']}")
                                break
                if not found:
                    print(f"Box will extend 100px to x={box_end_x} for PL{main_trendline['receiver']['receiver_arrow_number']}")
            else:
                print(f"No valid PH found as next parent for PL{main_trendline['receiver']['receiver_arrow_number']}, skipping box drawing")
                order_status = "none"
                box_end_x = min(receiver_x + 100, img_width)  # Default for JSON consistency
        else:  # PL-to-PH
            top_y = parent_candle[1]  # Top of PH candlestick
            bottom_y = parent_candle[2]  # Bottom of PH candlestick
            # Validate next parent for box drawing
            first_parent, second_parent = get_next_two_parents(receiver_x, pl_labels, ph_labels, 'PL-to-PH')
            valid_parent = False
            next_parent_x = None
            next_parent_type = None
            next_parent_y = None
            if first_parent == 'PL':
                valid_parent = True
                next_parent_x, next_parent_type, next_parent_y = get_next_parent_position(receiver_x, pl_labels, ph_labels, 'PL-to-PH')
            elif second_parent == 'PL':
                valid_parent = True
                # Find the second parent
                all_parents = [(x, parent_type, y) for x, parent_type, y in [(x, 'PL', y) for x, y, _, _ in pl_labels] + [(x, 'PH', y) for x, y, _, _ in ph_labels] if x > receiver_x]
                if len(all_parents) >= 2:
                    second_parent_data = sorted(all_parents, key=lambda p: p[0])[1]
                    next_parent_x, next_parent_type, next_parent_y = second_parent_data
            if valid_parent:
                # Check if the horizontal line at bottom_y touches a candlestick with higher top
                found = False
                box_end_x = min(receiver_x + 100, img_width)  # Default 100px box
                if next_parent_x is not None:
                    next_parent_candle, _ = get_candle_for_parent(next_parent_x, all_positions)
                    if next_parent_candle and next_parent_candle[1] < bottom_y:  # Top is higher (lower y)
                        box_end_x = next_parent_x
                        order_status = "executed"
                        found = True
                        print(f"Box will extend to {next_parent_type} at x={next_parent_x} for PH{main_trendline['receiver']['receiver_arrow_number']}")
                    else:
                        # Check candlesticks after the next valid PL
                        for pos_data, _ in sorted_positions:
                            if pos_data[0] > next_parent_x and pos_data[1] < bottom_y:  # Top is higher
                                box_end_x = pos_data[0]
                                order_status = "executed"
                                found = True
                                print(f"Box will extend to candlestick at x={pos_data[0]} for PH{main_trendline['receiver']['receiver_arrow_number']}")
                                break
                if not found:
                    print(f"Box will extend 100px to x={box_end_x} for PH{main_trendline['receiver']['receiver_arrow_number']}")
            else:
                print(f"No valid PL found as next parent for PH{main_trendline['receiver']['receiver_arrow_number']}, skipping box drawing")
                order_status = "none"
                box_end_x = min(receiver_x + 100, img_width)  # Default for JSON consistency
        
        # Update order_status in main_trendline_data
        main_trendline['receiver']['order_status'] = order_status
        
        # New condition: Check for "pending order" if order_status is not "executed" and next parent is valid
        if order_status != "executed" and valid_parent:
            latest_candle = get_latest_candle(sorted_positions)
            if latest_candle:
                if main_trendline['type'] == 'PH-to-PL':
                    # For PH-to-PL, check if latest candlestick's bottom is above receiver (PL) top
                    if latest_candle[2] < top_y:  # Latest bottom is higher (lower y)
                        order_status = "pending order"
                        main_trendline['receiver']['order_status'] = order_status
                        print(f"Set order_status to 'pending order' for PL{main_trendline['receiver']['receiver_arrow_number']} "
                              f"as latest candlestick bottom (y={latest_candle[2]}) is above receiver top (y={top_y})")
                else:  # PL-to-PH
                    # For PL-to-PH, check if latest candlestick's top is below receiver (PH) bottom
                    if latest_candle[1] > bottom_y:  # Latest top is lower (higher y)
                        order_status = "pending order"
                        main_trendline['receiver']['order_status'] = order_status
                        print(f"Set order_status to 'pending order' for PH{main_trendline['receiver']['receiver_arrow_number']} "
                              f"as latest candlestick top (y={latest_candle[1]}) is below receiver bottom (y={bottom_y})")
        
        # Draw box and handle stoploss logic only if a valid parent was found
        if order_status == "none" and valid_parent:
            # Draw box from top to bottom (PL) or bottom to top (PH), extend 100px to the right
            cv2.rectangle(img_main_trendlines, (receiver_x, top_y), (box_end_x, bottom_y), (255, 255, 255), 1)
            cv2.arrowedLine(img_main_trendlines, (box_end_x - 10, top_y), (box_end_x, top_y), (255, 255, 255), 1, tipLength=0.3)
            cv2.arrowedLine(img_main_trendlines, (box_end_x - 10, bottom_y), (box_end_x, bottom_y), (255, 255, 255), 1, tipLength=0.3)
            print(f"Drew box from (x={receiver_x}, y={top_y}) to (x={box_end_x}, y={bottom_y}) with right arrows for {main_trendline['type'].split('-')[2]}{main_trendline['receiver']['receiver_arrow_number']}, order_status=none")
            main_trendline['receiver']['stoploss_status'] = "none"
        elif order_status == "executed":
            # Calculate 's' label position
            candle_height = parent_candle[2] - parent_candle[1]  # bottom_y - top_y
            remaining_distance = 150 - candle_height
            if remaining_distance < 0:
                remaining_distance = 0
                print(f"Warning: Candlestick height {candle_height}px exceeds 150px for {main_trendline['type'].split('-')[2]}{main_trendline['receiver']['receiver_arrow_number']}, setting remaining distance to 0")
            
            if main_trendline['type'] == 'PH-to-PL':
                s_label_y = parent_candle[2] + remaining_distance
                s_label_position = (receiver_x - 20, s_label_y + 15)  # 15px below the 's' point
            else:
                s_label_y = parent_candle[1] - remaining_distance
                s_label_position = (receiver_x - 20, s_label_y - 5)  # 5px above the 's' point
            
            # Check for stoploss hit
            check_below = main_trendline['type'] == 'PH-to-PL'
            check_above = main_trendline['type'] == 'PL-to-PH'
            next_candle_x = get_next_candle_touched(receiver_x, s_label_y, sorted_positions, check_below=check_below, check_above=check_above)
            if next_candle_x is not None:
                # Stoploss hit: Draw box to the candlestick touched by the stoploss line, extending to s_label_y
                stoploss_status = "hit"
                box_end_x = next_candle_x
                cv2.rectangle(img_main_trendlines, 
                             (receiver_x, top_y if main_trendline['type'] == 'PH-to-PL' else s_label_y), 
                             (box_end_x, s_label_y if main_trendline['type'] == 'PH-to-PL' else bottom_y), 
                             (255, 255, 255), 1)
                print(f"Drew box from (x={receiver_x}, y={top_y if main_trendline['type'] == 'PH-to-PL' else s_label_y}) to "
                      f"(x={box_end_x}, y={s_label_y if main_trendline['type'] == 'PH-to-PL' else bottom_y}) for "
                      f"{main_trendline['type'].split('-')[2]}{main_trendline['receiver']['receiver_arrow_number']}, stoploss_status=hit")
            else:
                # Stoploss not hit: Draw box to the candlestick touched by the horizontal line, extend to 's' label
                stoploss_status = "free"
                cv2.rectangle(img_main_trendlines, 
                             (receiver_x, top_y if main_trendline['type'] == 'PH-to-PL' else s_label_y), 
                             (box_end_x, s_label_y if main_trendline['type'] == 'PH-to-PL' else bottom_y), 
                             (255, 255, 255), 1)
                # Draw 's' label
                s_label = f"s={int(remaining_distance)}"
                cv2.putText(img_main_trendlines, s_label, s_label_position, cv2.FONT_HERSHEY_SIMPLEX,
                            0.5, (255, 255, 255), 1, cv2.LINE_AA)
                # Draw 10px horizontal line with right arrow at 's' level
                arrow_end_x = box_end_x + 10
                if arrow_end_x <= img_width:
                    cv2.line(img_main_trendlines, (box_end_x, s_label_y), (arrow_end_x, s_label_y), (255, 255, 255), 1)
                    cv2.arrowedLine(img_main_trendlines, (arrow_end_x - 10, s_label_y), (arrow_end_x, s_label_y), (255, 255, 255), 1, tipLength=0.3)
                print(f"Drew box from (x={receiver_x}, y={top_y if main_trendline['type'] == 'PH-to-PL' else s_label_y}) to "
                      f"(x={box_end_x}, y={s_label_y if main_trendline['type'] == 'PH-to-PL' else bottom_y}) with 's' label "
                      f"and 10px arrow at y={s_label_y} for {main_trendline['type'].split('-')[2]}{main_trendline['receiver']['receiver_arrow_number']}, "
                      f"stoploss_status=free")
            
            # Update stoploss_status in main_trendline_data
            main_trendline['receiver']['stoploss_status'] = stoploss_status
        
        print(f"Connected {main_trendline['type']} from sender (pos={main_trendline['sender']['position_number']}, "
              f"color={main_trendline['sender']['candle_color']}) "
              f"to receiver (pos={main_trendline['receiver']['position_number']}, "
              f"color={main_trendline['receiver']['candle_color']}) "
              f"with {'green' if main_trendline['type'] == 'PH-to-PL' else 'yellow'} main_trendline, "
              f"order_type={main_trendline['receiver']['order_type']}, order_status={main_trendline['receiver']['order_status']}, "
              f"stoploss_status={main_trendline['receiver']['stoploss_status']}, "
              f"next parent: {main_trendline['receiver'].get('next_parent', 'invalid')}")
    
    # Save the main_trendline image
    main_trendline_image_path = os.path.join(OUTPUT_FOLDER, f"{base_name}_parent_main_trendlines.png")
    cv2.imwrite(main_trendline_image_path, img_main_trendlines)
    print(f"Parent main_trendlines image saved to: {main_trendline_image_path}")
    
    return main_trendline_image_path, main_trendline_data

def save_main_trendline_data_to_json(main_trendline_data):
    """
    Save the main_trendline data to a JSON file named contracts.json in the OUTPUT_FOLDER.
    
    Args:
        main_trendline_data (list): List of dictionaries containing main_trendline details.
    
    Returns:
        str: Path to the saved JSON file.
    """
    json_path = os.path.join(OUTPUT_FOLDER, "contracts.json")
    try:
        with open(json_path, 'w') as f:
            json.dump(main_trendline_data, f, indent=4)
        print(f"main_trendline data saved to: {json_path}")
    except Exception as e:
        print(f"Error saving main_trendline data to JSON: {e}")
    return json_path

def latestmain_trendline(switch):
    """
    Control whether to show or hide the last main_trendline when there is no parent ahead of the receiver.
    
    Args:
        switch (str): "show" to allow the last main_trendline, "hide" to restrict it.
    
    Returns:
        bool: True if the last main_trendline should be shown, False otherwise.
    """
    valid_options = ["show", "hide"]
    if switch.lower() not in valid_options:
        print(f"Invalid switch value '{switch}', defaulting to 'hide'")
        return False
    return switch.lower() == "show"

def main_trendlinecontracts(number):
    """
    Validate the number of contract points (CPs) and their associated main_trendlines to display.
    Starts from the rightmost (latest) main_trendline and selects sequentially leftward.
    
    Args:
        number (str): Number of contract points to display (e.g., "1", "2"). If "0", display none.
                     If greater than available main_trendlines, display all.
    
    Returns:
        int: Validated number of contract points to display, defaults to 0 if invalid.
    """
    try:
        num_contracts = int(number)
        if num_contracts < 0:
            print(f"Number of contracts {num_contracts} is negative, defaulting to 0")
            num_contracts = 0
        return num_contracts
    except ValueError:
        print(f"Invalid number of contracts {number}, defaulting to 0")
        return 0

def PHandPLmain_trendlinedistancecontrol(distance):
    """
    Validate the distance threshold for main_trendlines between sender (PH/PL) and the target candlestick.
    
    Args:
        distance (str): The minimum vertical distance in pixels (e.g., "0", "10", "20", "50", "100", "200").
    
    Returns:
        int: Validated distance threshold, defaults to 0 if invalid or not in allowed values.
    """
    allowed_distances = [0, 10, 20, 50, 100, 200]
    try:
        dist = int(distance)
        if dist not in allowed_distances:
            print(f"Distance {dist} is not in allowed values {allowed_distances}, defaulting to 0")
            dist = 0
    except ValueError:
        print(f"Invalid distance {distance}, defaulting to 0")
        dist = 0
    
    return dist

def main_trendlinetocandleposition(position):
    """
    Validate the candlestick position to connect main_trendlines to (1 to 5).
    
    Args:
        position (str): The position of the candlestick to the right (1 to 5).
    
    Returns:
        str: Validated position as a string (1 to 5), defaults to "1" if invalid or out of range.
    """
    try:
        pos = int(position)
        if pos > 5 or pos < 1:
            print(f"Position {pos} is out of range (1-5), defaulting to 1")
            pos = 1
    except ValueError:
        print(f"Invalid position {position}, defaulting to 1")
        pos = 1
    
    return str(pos)



#FALLBACK 
def draw_parent_fallback_trendlines(img_parent_labeled, all_positions, base_name, left_required, right_required, 
                                   fallback_trendline_position, distance_threshold, num_contracts, allow_latest_fallback_trendline,
                                   pl_labels, ph_labels):
  
    img_fallback_trendlines = img_parent_labeled.copy()
    total_candles = len(all_positions)
    
    # Get image dimensions for boundary checks
    img_width = img_fallback_trendlines.shape[1]
    img_height = img_fallback_trendlines.shape[0]
    
    # Font settings for position numbers, 'inst', 'tp', 'BE', 'sl' labels
    font = cv2.FONT_HERSHEY_SIMPLEX
    font_scale = 0.5
    text_color = (255, 255, 255)  # White text
    thickness = 1
    line_type = cv2.LINE_AA
    
    # Draw position numbers for PL and PH
    for x, bottom_y, label, arrow_number in pl_labels:
        text_position = (x - 20, bottom_y + 35)  # 20px below PL label
        cv2.putText(img_fallback_trendlines, str(arrow_number), text_position, font,
                    font_scale, text_color, thickness, line_type)
    
    for x, top_y, label, arrow_number in ph_labels:
        text_position = (x - 20, top_y - 25)  # 10px above PH label
        cv2.putText(img_fallback_trendlines, str(arrow_number), text_position, font,
                    font_scale, text_color, thickness, line_type)
    
    # Sort all_positions by x-coordinate
    sorted_positions = sorted(all_positions, key=lambda x: x[0][0])
    
    # Track used points for PH-to-PL and PL-to-PH connections
    used_points_ph_to_pl = set()
    used_points_pl_to_ph = set()
    
    # Initialize list to store fallback trendline data for JSON
    fallback_trendline_data = []
    instant_contracts = []  # List to store contracts with 'inst' label
    
    # Initialize list to store parent distances for JSON
    parent_distances = []
    
    # Calculate PH-to-PH vertical distances
    ph_labels_sorted = sorted(ph_labels, key=lambda x: x[0])
    for i in range(len(ph_labels_sorted) - 1):
        x1, top_y1, label1, arrow_number1 = ph_labels_sorted[i]
        x2, top_y2, label2, arrow_number2 = ph_labels_sorted[i + 1]
        distance = abs(top_y1 - top_y2)
        parent_distances.append({
            "type": "PH-to-PH",
            "from_label": label1,
            "to_label": label2,
            "vertical_distance_px": distance
        })
        print(f"PH-to-PH distance from {label1} (x={x1}, y={top_y1}) to {label2} (x={x2}, y={top_y2}): {distance}px")
    
    # Calculate PL-to-PL vertical distances
    pl_labels_sorted = sorted(pl_labels, key=lambda x: x[0])
    for i in range(len(pl_labels_sorted) - 1):
        x1, bottom_y1, label1, arrow_number1 = pl_labels_sorted[i]
        x2, bottom_y2, label2, arrow_number2 = pl_labels_sorted[i + 1]
        distance = abs(bottom_y1 - bottom_y2)
        parent_distances.append({
            "type": "PL-to-PL",
            "from_label": label1,
            "to_label": label2,
            "vertical_distance_px": distance
        })
        print(f"PL-to-PL distance from {label1} (x={x1}, y={bottom_y1}) to {label2} (x={x2}, y={bottom_y2}): {distance}px")
    
    # Save parent distances to a separate JSON file
    parent_distances_json_path = os.path.join(OUTPUT_FOLDER, "parent_distances.json")
    try:
        with open(parent_distances_json_path, 'w') as f:
            json.dump(parent_distances, f, indent=4)
        print(f"Parent distances saved to: {parent_distances_json_path}")
    except Exception as e:
        print(f"Error saving parent distances to JSON: {e}")
    
    # Helper function to find candlestick at specified position
    def get_candle_at_position(receiver_x, position):
        try:
            pos = int(position)
        except ValueError:
            pos = 1
        count = 0
        for pos_data, color in sorted_positions:
            if pos_data[0] > receiver_x:
                count += 1
                if count == pos:
                    return pos_data, color
        print(f"No candlestick found at position {position} to the right of x={receiver_x}")
        return None, None
    
    # Helper function to check if a fallback trendline crosses another PH or PL
    def crosses_other_parent(start_x, end_x, start_y, end_y, points_to_check, exclude_labels=None):
        if exclude_labels is None:
            exclude_labels = set()
        for x, y, label, _ in points_to_check:
            if label in exclude_labels:
                continue
            if start_x < x < end_x:
                if start_x != end_x:
                    t = (x - start_x) / (end_x - start_x)
                    line_y = start_y + t * (end_y - start_y)
                    if abs(line_y - y) < 20:
                        return True, label
        return False, None
    
    # Helper function to extend line to the right edge of the image
    def extend_line_to_right_edge(start_x, start_y, target_x, target_y, img_width):
        if target_x == start_x:
            return img_width, start_y
        m = (target_y - start_y) / (target_x - start_x)
        c = start_y - m * start_x
        end_y = m * img_width + c
        return img_width, int(end_y)
    
    # Helper function to count parents ahead
    def count_parents_ahead(x, parent_points):
        return sum(1 for p in parent_points if p[0] > x)
    
    # Helper function to extract position number from label
    def get_position_number_from_label(label):
        try:
            return int(label[2:])
        except ValueError:
            return None
    
    # Helper function to get position number for a candlestick
    def get_position_number(x, labels, all_positions):
        for px, _, label, _ in labels:
            if px == x:
                pos_number = get_position_number_from_label(label)
                if pos_number is not None:
                    return pos_number
        for i, (pos, _) in enumerate(reversed(all_positions[:-1]), 1):
            if pos[0] == x:
                return i
        return None
    
    # Helper function to get the second next parent after the receiver
    def get_second_next_parent(receiver_x, pl_labels, ph_labels, fallback_trendline_type):
        all_parents = [(x, 'PL', y) for x, y, _, _ in pl_labels] + [(x, 'PH', y) for x, y, _, _ in ph_labels]
        parents_to_right = sorted([(x, parent_type, y) for x, parent_type, y in all_parents if x > receiver_x], key=lambda p: p[0])
        if len(parents_to_right) < 2:
            print(f"Not enough parents to the right of x={receiver_x} for {fallback_trendline_type}")
            return None, None, None
        second_parent = parents_to_right[1]
        expected_type = 'PL' if fallback_trendline_type == 'PH-to-PL' else 'PH'
        if second_parent[1] != expected_type:
            print(f"Second parent at x={second_parent[0]} is {second_parent[1]}, expected {expected_type} for {fallback_trendline_type}")
            return None, None, None
        return second_parent[0], second_parent[1], second_parent[2]
    
    # Helper function to find the candlestick that contains a parent
    def get_candle_for_parent(parent_x, all_positions):
        for pos, color in all_positions:
            if pos[0] == parent_x:
                return pos, color
        print(f"No candlestick found for parent at x={parent_x}")
        return None, None
    
    # Helper function to find the second candle after second_next_parent
    def get_second_candle_after_parent(parent_x, sorted_positions):
        candles_after = [pos for pos, _ in sorted_positions if pos[0] > parent_x]
        if len(candles_after) < 2:
            print(f"Not enough candles after parent at x={parent_x} to find second candle")
            return None
        return candles_after[1]
    
    # Helper function to find the second candle after second_next_parent that satisfies the condition for PH-to-PL
    def find_suitable_candle_ph_to_pl(second_next_parent_x, second_next_parent_bottom_y, first_candle_x, first_candle_bottom_y, sorted_positions):
        candles_after = [pos for pos, _ in sorted_positions if pos[0] > second_next_parent_x]
        if len(candles_after) < 2:
            print(f"Not enough candles after second_next_parent at x={second_next_parent_x} to find suitable candle")
            return None, None
        second_candle = candles_after[1]
        for i, pos in enumerate(candles_after[1:], 2):
            if pos[2] < first_candle_bottom_y:
                print(f"Found suitable candle at position {i} after second_next_parent at x={second_next_parent_x}, bottom_y={pos[2]}")
                return pos, second_candle
        print(f"No suitable candle found after second_next_parent at x={second_next_parent_x}")
        return None, second_candle
    
    # Helper function to find the second candle after second_next_parent that satisfies the condition for PL-to-PH
    def find_suitable_candle_pl_to_ph(second_next_parent_x, second_next_parent_top_y, first_candle_x, first_candle_top_y, sorted_positions):
        candles_after = [pos for pos, _ in sorted_positions if pos[0] > second_next_parent_x]
        if len(candles_after) < 2:
            print(f"Not enough candles after second_next_parent at x={second_next_parent_x} to find suitable candle")
            return None, None
        second_candle = candles_after[1]
        for i, pos in enumerate(candles_after[1:], 2):
            if pos[1] > first_candle_top_y:
                print(f"Found suitable candle at position {i} after second_next_parent at x={second_next_parent_x}, top_y={pos[1]}")
                return pos, second_candle
        print(f"No suitable candle found after second_next_parent at x={second_next_parent_x}")
        return None, second_candle
    
    # Helper function to find a candlestick ahead that matches the specified y-level
    def find_candle_at_height(vertical_x, y_level, sorted_positions, check_top=False, check_bottom=False, tolerance=5):
        for pos, _ in sorted_positions:
            if pos[0] >= vertical_x:
                if check_top and abs(pos[1] - y_level) <= tolerance:
                    return pos
                if check_bottom and abs(pos[2] - y_level) <= tolerance:
                    return pos
        return None
    
    # Helper function to check if the candle is the latest
    def is_latest_candle(candle_x, sorted_positions):
        return all(pos[0] <= candle_x for pos, _ in sorted_positions)
    
    # Helper function to draw horizontal and vertical lines and determine labels
    def draw_first_matching_line(vertical_x, open_y, sorted_positions, is_ph_to_pl, left_x, right_x, arrow_number, parent_type):
        if left_x is None or right_x is None:
            print(f"Cannot draw horizontal lines for {parent_type}{arrow_number} at x={vertical_x}: left_x={left_x}, right_x={right_x}")
            return False, "none", "none", "none", "none"
        
        levels = [
            (450, '1:3', -450 if is_ph_to_pl else 450),  # 150*3px for tp
            (300, '1:2', -300 if is_ph_to_pl else 300),  # 150*2px
            (150, '1:1', -150 if is_ph_to_pl else 150),  # 150*1px
            (50, 'esp', -50 if is_ph_to_pl else 50),     # 50px
            (150, 'sl', 150 if is_ph_to_pl else -150)    # 150px for sl
        ]
        
        # Track hits with x-coordinates
        hits = []
        be_level = None
        be_y_level = None
        tp_hit_x = None
        tp_y_level = None
        
        # Check for candlestick matches at each level
        for distance, label, y_offset in levels:
            y_level = open_y + y_offset
            y_level = max(0, min(img_height - 1, y_level))
            candle = find_candle_at_height(vertical_x, y_level, sorted_positions, 
                                        check_top=is_ph_to_pl, check_bottom=not is_ph_to_pl, tolerance=5)
            if candle:
                hits.append((label, candle[0], y_level))
                if label in ['1:2', '1:1', 'esp'] and be_level is None:
                    be_level = label
                    be_y_level = y_level
                if label == '1:3':
                    tp_hit_x = candle[0]
                    tp_y_level = y_level
        
        # Initialize labels and JSON fields
        sl_label = "sl"
        tp_label = "tphit"
        breakeven_status = "none"
        stoploss_status = "none"
        takeprofit_status = "none"
        order_status = "none"
        
        # Draw 'sl' line and label
        sl_y_level = open_y + (150 if is_ph_to_pl else -150)
        sl_y_level = max(0, min(img_height - 1, sl_y_level))
        cv2.line(img_fallback_trendlines, (left_x, sl_y_level), (right_x, sl_y_level), (255, 255, 255), 1)
        # Place 'sl' or 'nosl' label above for PL-to-PH (sell), below for PH-to-PL (buy)
        sl_label_y = sl_y_level - 15 if not is_ph_to_pl else sl_y_level + 15
        cv2.putText(img_fallback_trendlines, sl_label, (left_x, sl_label_y), font, font_scale, text_color, thickness, line_type)
        print(f"Drew horizontal closing line at y={sl_y_level} ('{sl_label}') from x={left_x} to x={right_x} for {parent_type}{arrow_number}")
        
        # Draw vertical line at left_x for 'sl'
        start_y = open_y if (is_ph_to_pl and sl_y_level > open_y) or (not is_ph_to_pl and sl_y_level < open_y) else sl_y_level
        end_y = sl_y_level if (is_ph_to_pl and sl_y_level > open_y) or (not is_ph_to_pl and sl_y_level < open_y) else open_y
        cv2.line(img_fallback_trendlines, (left_x, start_y), (left_x, end_y), (255, 255, 255), 1)
        print(f"Drew left vertical line at x={left_x} from y={start_y} to y={end_y} for {parent_type}{arrow_number} (sl)")
        
        # Draw vertical line at right_x for 'sl'
        cv2.line(img_fallback_trendlines, (right_x, start_y), (right_x, end_y), (255, 255, 255), 1)
        print(f"Drew right vertical line at x={right_x} from y={start_y} to y={end_y} for {parent_type}{arrow_number} (sl)")
        
        # Determine which level was hit first based on x-coordinate
        if hits:
            earliest_hit = min(hits, key=lambda x: x[1])  # Smallest x-coordinate
            earliest_label = earliest_hit[0]
            earliest_x = earliest_hit[1]
            earliest_y = earliest_hit[2]
            
            # Check for simultaneous hits (same x-coordinate)
            simultaneous_hits = [hit for hit in hits if hit[1] == earliest_x]
            if len(simultaneous_hits) > 1:
                # Prioritize '1:3' (tp) if present
                if any(hit[0] == '1:3' for hit in simultaneous_hits):
                    earliest_label = '1:3'
                    earliest_y = next(hit[2] for hit in simultaneous_hits if hit[0] == '1:3')
                    earliest_x = next(hit[1] for hit in simultaneous_hits if hit[0] == '1:3')
                else:
                    # Prioritize BE levels ('1:2', '1:1', 'esp') over 'sl'
                    be_hits = [hit for hit in simultaneous_hits if hit[0] in ['1:2', '1:1', 'esp']]
                    if be_hits:
                        # Choose the BE level with the smallest absolute difference to the previous candle
                        prev_candle = None
                        for pos, _ in sorted_positions:
                            if pos[0] < earliest_x:
                                prev_candle = pos
                            else:
                                break
                        if prev_candle:
                            prev_differences = []
                            for label, _, y_level in be_hits:
                                if is_ph_to_pl:
                                    diff = y_level - prev_candle[1]  # Compare to top
                                else:
                                    diff = prev_candle[2] - y_level  # Compare to bottom
                                prev_differences.append((diff, label, y_level))
                            earliest = min(prev_differences, key=lambda x: abs(x[0]))
                            earliest_label = earliest[1]
                            earliest_y = earliest[2]
                        else:
                            earliest_label = be_hits[0][0]
                            earliest_y = be_hits[0][2]
                    else:
                        earliest_label = simultaneous_hits[0][0]
                        earliest_y = simultaneous_hits[0][2]
            
            # If '1:3' is hit first or simultaneously
            if earliest_label == '1:3':
                # Draw '1:3' line and label
                cv2.line(img_fallback_trendlines, (left_x, earliest_y), (right_x, earliest_y), (255, 255, 255), 1)
                cv2.putText(img_fallback_trendlines, tp_label, (left_x, earliest_y + 15), font, font_scale, text_color, thickness, line_type)
                # Update 'sl' label to 'nosl'
                sl_y_level = open_y + (150 if is_ph_to_pl else -150)
                sl_y_level = max(0, min(img_height - 1, sl_y_level))
                cv2.line(img_fallback_trendlines, (left_x, sl_y_level), (right_x, sl_y_level), (255, 255, 255), 1)  # Redraw to ensure visibility
                # Place 'nosl' label above for PL-to-PH (sell), below for PH-to-PL (buy)
                sl_label_y = sl_y_level - 15 if not is_ph_to_pl else sl_y_level + 15
                cv2.putText(img_fallback_trendlines, "nosl", (left_x, sl_label_y), font, font_scale, text_color, thickness, line_type)
                breakeven_status = "no BE"
                stoploss_status = "no loss"
                takeprofit_status = "hits tp"
                order_status = "executed"  # TP hit
                print(f"TP hit first at x={earliest_x}, y={earliest_y} for {parent_type}{arrow_number}")
                print(f"Drew horizontal line at y={earliest_y} ('{tp_label}') from x={left_x} to x={right_x} for {parent_type}{arrow_number}")
                return True, breakeven_status, stoploss_status, takeprofit_status, order_status
            
            # If a breakeven level is hit first
            if earliest_label in ['1:2', '1:1', 'esp']:
                # Check for a subsequent '1:3' hit
                tp_hit = any(hit[0] == '1:3' and hit[1] > earliest_x for hit in hits)
                if tp_hit:
                    # Draw '1:3' line and label, skip 'BE'
                    cv2.line(img_fallback_trendlines, (left_x, tp_y_level), (right_x, tp_y_level), (255, 255, 255), 1)
                    cv2.putText(img_fallback_trendlines, tp_label, (left_x, tp_y_level + 15), font, font_scale, text_color, thickness, line_type)
                    # Update 'sl' label to 'nosl'
                    sl_y_level = open_y + (150 if is_ph_to_pl else -150)
                    sl_y_level = max(0, min(img_height - 1, sl_y_level))
                    cv2.line(img_fallback_trendlines, (left_x, sl_y_level), (right_x, sl_y_level), (255, 255, 255), 1)  # Redraw to ensure visibility
                    sl_label_y = sl_y_level - 15 if not is_ph_to_pl else sl_y_level + 15
                    cv2.putText(img_fallback_trendlines, "nosl", (left_x, sl_label_y), font, font_scale, text_color, thickness, line_type)
                    # Draw vertical lines for '1:3'
                    start_y = open_y if (is_ph_to_pl and tp_y_level > open_y) or (not is_ph_to_pl and tp_y_level < open_y) else tp_y_level
                    end_y = tp_y_level if (is_ph_to_pl and tp_y_level > open_y) or (not is_ph_to_pl and tp_y_level < open_y) else open_y
                    cv2.line(img_fallback_trendlines, (left_x, start_y), (left_x, end_y), (255, 255, 255), 1)
                    cv2.line(img_fallback_trendlines, (right_x, start_y), (right_x, end_y), (255, 255, 255), 1)
                    breakeven_status = "no BE"
                    stoploss_status = "no loss"
                    takeprofit_status = "hits tp"
                    order_status = "executed"  # TP hit after BE
                    print(f"BE hit at x={earliest_x}, y={earliest_y}, but TP hit later at x={tp_hit_x}, y={tp_y_level} for {parent_type}{arrow_number}")
                    print(f"Drew horizontal line at y={tp_y_level} ('{tp_label}') from x={left_x} to x={right_x} for {parent_type}{arrow_number}")
                else:
                    # Draw 'BE' line and label
                    cv2.line(img_fallback_trendlines, (left_x, earliest_y), (right_x, earliest_y), (255, 255, 255), 1)
                    midpoint_x = (left_x + right_x) // 2
                    cv2.putText(img_fallback_trendlines, 'BE', (midpoint_x, earliest_y + 15), font, font_scale, text_color, thickness, line_type)
                    # Draw vertical lines for 'BE'
                    start_y = open_y if (is_ph_to_pl and earliest_y > open_y) or (not is_ph_to_pl and earliest_y < open_y) else earliest_y
                    end_y = earliest_y if (is_ph_to_pl and earliest_y > open_y) or (not is_ph_to_pl and earliest_y < open_y) else open_y
                    cv2.line(img_fallback_trendlines, (left_x, start_y), (left_x, end_y), (255, 255, 255), 1)
                    cv2.line(img_fallback_trendlines, (right_x, start_y), (right_x, end_y), (255, 255, 255), 1)
                    # Check if 'sl' is hit after 'BE'
                    sl_hit = any(hit[0] == 'sl' and hit[1] > earliest_x for hit in hits)
                    if sl_hit:
                        breakeven_status = "BE"
                        stoploss_status = "hits BE"
                        takeprofit_status = "hits BE"
                        order_status = "executed"  # BE hit
                        print(f"BE hit first at x={earliest_x}, y={earliest_y}, SL hit later for {parent_type}{arrow_number}")
                    else:
                        breakeven_status = "BE"
                        stoploss_status = "none"
                        takeprofit_status = "hits BE"
                        order_status = "executed"  # BE hit
                        print(f"BE hit first at x={earliest_x}, y={earliest_y}, no TP or SL hit for {parent_type}{arrow_number}")
                    print(f"Drew horizontal closing line at y={earliest_y} ('BE') from x={left_x} to x={right_x} for {parent_type}{arrow_number}")
                return True, breakeven_status, stoploss_status, takeprofit_status, order_status
        
        # No hits found, check for instant buy/sell or running
        esp_y_level = open_y + (-50 if is_ph_to_pl else 50)
        esp_y_level = max(0, min(img_height - 1, esp_y_level))
        # Find the second candle used for 'inst'
        second_candle = None
        for pos, _ in sorted_positions:
            if pos[0] == right_x:
                second_candle = pos
                break
        if second_candle:
            is_latest = is_latest_candle(right_x, sorted_positions)
            # Check if the second candle is within esp (50px)
            within_esp = False
            if is_ph_to_pl:
                within_esp = abs(second_candle[1] - open_y) <= 50  # Check top for buy
            else:
                within_esp = abs(second_candle[2] - open_y) <= 50  # Check bottom for sell
            if within_esp and is_latest:
                order_status = "instant buy" if is_ph_to_pl else "instant sell"
                print(f"No hits, second candle at x={right_x} is within esp and latest, setting order_status={order_status} for {parent_type}{arrow_number}")
            else:
                order_status = "running"
                print(f"No hits, second candle at x={right_x} is {'not within esp' if not within_esp else 'not latest'}, setting order_status=running for {parent_type}{arrow_number}")
        else:
            order_status = "running"
            print(f"No hits, no second candle found at x={right_x}, setting order_status=running for {parent_type}{arrow_number}")
        
        return False, breakeven_status, stoploss_status, takeprofit_status, order_status
    
    # PH to PL (top to top of the candlestick at specified position to the right of the nearest PL, green, 2px)
    for i, (x1, top_y1, label1, arrow_number1) in enumerate(ph_labels):
        if label1 in used_points_ph_to_pl:
            continue
        
        nearest_pl = None
        min_distance = float('inf')
        for j, (x2, bottom_y2, label2, arrow_number2) in enumerate(pl_labels):
            if x2 > x1 and label2 not in used_points_ph_to_pl:
                distance = x2 - x1
                if distance < min_distance:
                    min_distance = distance
                    nearest_pl = (x2, bottom_y2, label2, arrow_number2)
        
        if nearest_pl is None:
            print(f"No unused PL found to the right of {label1}, skipping connection")
            continue
        
        x2, bottom_y2, label2, arrow_number2 = nearest_pl
        
        if not allow_latest_fallback_trendline:
            ph_ahead_count = count_parents_ahead(x2, ph_labels)
            if ph_ahead_count == 0:
                print(f"No PH found ahead of {label2}, skipping PH-to-PL fallback trendline from {label1}")
                continue
        
        next_candle, receiver_color = get_candle_at_position(x2, fallback_trendline_position)
        if next_candle is None:
            print(f"No candlestick found at position {fallback_trendline_position} to the right of {label2}, skipping connection")
            continue
        
        if next_candle[1] <= top_y1:
            print(f"Skipping PH-to-PL fallback trendline from {label1} to candlestick at position {fallback_trendline_position} right of {label2} "
                  f"because receiver top (y={next_candle[1]}) is higher than or equal to sender top (y={top_y1})")
            continue
        
        vertical_distance = abs(top_y1 - next_candle[1])
        if vertical_distance < distance_threshold:
            print(f"Skipping PH-to-PL fallback trendline from {label1} to candlestick at position {fallback_trendline_position} right of {label2} "
                  f"due to vertical distance {vertical_distance} < threshold {distance_threshold}")
            continue
        
        crosses, crossed_label = crosses_other_parent(
            x1, next_candle[0], top_y1, next_candle[1],
            pl_labels + ph_labels,
            exclude_labels={label1, label2}
        )
        if crosses:
            print(f"Skipping PH-to-PL fallback trendline from {label1} to candlestick at position {fallback_trendline_position} right of {label2} "
                  f"due to crossing {crossed_label}")
            continue
        
        end_x, end_y = extend_line_to_right_edge(x1, top_y1, next_candle[0], next_candle[1], img_width)
        
        crosses, crossed_label = crosses_other_parent(
            next_candle[0], end_x, next_candle[1], end_y,
            pl_labels + ph_labels,
            exclude_labels={label1, label2}
        )
        if crosses:
            print(f"Skipping PH-to-PL fallback trendline extension from {label1} to candlestick at position {fallback_trendline_position} right of {label2} "
                  f"due to crossing {crossed_label} in extension")
            continue
        
        sender_color = [color for pos, color in all_positions if pos[0] == x1][0]
        sender_pos_number = get_position_number_from_label(label1)
        receiver_pos_number = get_position_number(next_candle[0], pl_labels + ph_labels, all_positions)
        
        # Get the second next parent (PL) for vertical line
        second_next_parent_x, second_next_parent_type, second_next_parent_y = get_second_next_parent(x2, pl_labels, ph_labels, 'PH-to-PL')
        
        # Initialize order_type and JSON fields
        order_type = "none"
        breakeven_status = "none"
        stoploss_status = "none"
        takeprofit_status = "none"
        order_status = "none"
        
        # Check for horizontal line conditions for PH-to-PL
        if second_next_parent_x and second_next_parent_type == 'PL':
            parent_candle, parent_color = get_candle_for_parent(x2, all_positions)
            if parent_candle is None:
                print(f"No parent candle found for PL{arrow_number2} at x={x2}, skipping horizontal line")
            elif second_next_parent_y < parent_candle[1]:
                first_candle = None
                for pos, _ in sorted_positions:
                    if pos[0] > second_next_parent_x:
                        first_candle = pos
                        break
                if first_candle is None:
                    print(f"No first candle found after second_next_parent at x={second_next_parent_x} for PL{arrow_number2}")
                else:
                    first_candle_bottom_y = first_candle[2]
                    suitable_candle, second_candle = find_suitable_candle_ph_to_pl(second_next_parent_x, second_next_parent_y, first_candle[0], first_candle_bottom_y, sorted_positions)
                    if suitable_candle is None or second_candle is None:
                        print(f"No suitable candle or second candle found for PL{arrow_number2}, setting order_type to none")
                    else:
                        line_y = second_candle[1]
                        line_start_x = suitable_candle[0]
                        line_end_x = min(line_start_x + 50, img_width)
                        cv2.line(img_fallback_trendlines, (line_start_x, line_y), (line_end_x, line_y), (255, 255, 255), 1)
                        inst_position = (line_start_x, line_y + 15)
                        cv2.putText(img_fallback_trendlines, 'inst', inst_position, font, font_scale, text_color, thickness, line_type)
                        order_type = "instant buy"
                        print(f"Drew horizontal line at y={line_y} from x={line_start_x} to x={line_end_x} with 'inst' label for PL{arrow_number2}")
                        # Draw vertical line and determine labels
                        success, breakeven_status, stoploss_status, takeprofit_status, order_status = draw_first_matching_line(
                            line_end_x, line_y, sorted_positions, True, line_start_x, line_end_x, arrow_number2, 'PL'
                        )
                        if success:
                            print(f"Drew vertical lines at x={line_start_x} (left) and x={line_end_x} (right) from y={line_y} with labels for PL{arrow_number2}")
                        else:
                            # Override order_status based on no hits
                            order_type = order_status  # Use order_status from draw_first_matching_line
                            print(f"No hits, using order_status={order_type} from draw_first_matching_line for PL{arrow_number2}")
        
        # Create fallback trendline data entry with updated statuses
        fallback_trendline_entry = {
            "type": "PH-to-PL",
            "sender": {
                "candle_color": sender_color,
                "position_number": sender_pos_number
            },
            "receiver": {
                "candle_color": receiver_color,
                "position_number": receiver_pos_number,
                "order_type": order_type,
                "next_parent": second_next_parent_type if second_next_parent_x else "invalid",
                "receiver_arrow_number": arrow_number2,
                "Breakeven": breakeven_status,
                "Stoploss_status": stoploss_status,
                "Takeprofit": takeprofit_status,
                "order_status": order_status
            }
        }
        fallback_trendline_data.append(fallback_trendline_entry)
        
        # Add to instant_contracts if order_type is "instant buy"
        if order_type == "instant buy":
            instant_contracts.append(fallback_trendline_entry)
        
        used_points_ph_to_pl.add(label1)
        used_points_ph_to_pl.add(label2)
    
    # PL to PH (bottom to bottom of the candlestick at specified position to the right of the nearest PH, yellow, 2px)
    for i, (x1, bottom_y1, label1, arrow_number1) in enumerate(pl_labels):
        if label1 in used_points_pl_to_ph:
            continue
        
        nearest_ph = None
        min_distance = float('inf')
        for j, (x2, top_y2, label2, arrow_number2) in enumerate(ph_labels):
            if x2 > x1 and label2 not in used_points_pl_to_ph:
                distance = x2 - x1
                if distance < min_distance:
                    min_distance = distance
                    nearest_ph = (x2, top_y2, label2, arrow_number2)
        
        if nearest_ph is None:
            print(f"No unused PH found to the right of {label1}, skipping connection")
            continue
        
        x2, top_y2, label2, arrow_number2 = nearest_ph
        
        if not allow_latest_fallback_trendline:
            pl_ahead_count = count_parents_ahead(x2, pl_labels)
            if pl_ahead_count == 0:
                print(f"No PL found ahead of {label2}, skipping PL-to-PH fallback trendline from {label1}")
            continue
        
        next_candle, receiver_color = get_candle_at_position(x2, fallback_trendline_position)
        if next_candle is None:
            print(f"No candlestick at position {fallback_trendline_position} to the right of {label2}, skipping connection")
            continue
        
        if next_candle[2] >= bottom_y1:
            print(f"Skipping PL-to-PH fallback trendline from {label1} to candlestick at position {fallback_trendline_position} right of {label2} "
                  f"because receiver bottom (y={next_candle[2]}) is lower than or equal to sender bottom (y={bottom_y1})")
            continue
        
        vertical_distance = abs(bottom_y1 - next_candle[2])
        if vertical_distance < distance_threshold:
            print(f"Skipping PL-to-PH fallback trendline from {label1} to candlestick at position {fallback_trendline_position} right of {label2} "
                  f"due to vertical distance {vertical_distance} < threshold {distance_threshold}")
            continue
        
        crosses, crossed_label = crosses_other_parent(
            x1, next_candle[0], bottom_y1, next_candle[2],
            pl_labels + ph_labels,
            exclude_labels={label1, label2}
        )
        if crosses:
            print(f"Skipping PL-to-PH fallback trendline from {label1} to candlestick at position {fallback_trendline_position} right of {label2} "
                  f"due to crossing {crossed_label}")
            continue
        
        end_x, end_y = extend_line_to_right_edge(x1, bottom_y1, next_candle[0], next_candle[2], img_width)
        
        crosses, crossed_label = crosses_other_parent(
            next_candle[0], end_x, next_candle[2], end_y,
            pl_labels + ph_labels,
            exclude_labels={label1, label2}
        )
        if crosses:
            print(f"Skipping PL-to-PH fallback trendline extension from {label1} to candlestick at position {fallback_trendline_position} right of {label2} "
                  f"due to crossing {crossed_label} in extension")
            continue
        
        sender_color = [color for pos, color in all_positions if pos[0] == x1][0]
        sender_pos_number = get_position_number_from_label(label1)
        receiver_pos_number = get_position_number(next_candle[0], pl_labels + ph_labels, all_positions)
        
        # Get the second next parent (PH) for vertical line
        second_next_parent_x, second_next_parent_type, second_next_parent_y = get_second_next_parent(x2, pl_labels, ph_labels, 'PL-to-PH')
        
        # Initialize order_type and JSON fields
        order_type = "none"
        breakeven_status = "none"
        stoploss_status = "none"
        takeprofit_status = "none"
        order_status = "none"
        
        # Check for horizontal line conditions for PL-to-PH
        if second_next_parent_x and second_next_parent_type == 'PH':
            parent_candle, parent_color = get_candle_for_parent(x2, all_positions)
            if parent_candle is None:
                print(f"No parent candle found for PH{arrow_number2} at x={x2}, skipping horizontal line")
            elif second_next_parent_y > parent_candle[2]:
                first_candle = None
                for pos, _ in sorted_positions:
                    if pos[0] > second_next_parent_x:
                        first_candle = pos
                        break
                if first_candle is None:
                    print(f"No first candle found after second_next_parent at x={second_next_parent_x} for PH{arrow_number2}")
                else:
                    first_candle_top_y = first_candle[1]
                    suitable_candle, second_candle = find_suitable_candle_pl_to_ph(second_next_parent_x, second_next_parent_y, first_candle[0], first_candle_top_y, sorted_positions)
                    if suitable_candle is None or second_candle is None:
                        print(f"No suitable candle or second candle found for PH{arrow_number2}, setting order_type to none")
                    else:
                        line_y = second_candle[2]
                        line_start_x = suitable_candle[0]
                        line_end_x = min(line_start_x + 50, img_width)
                        cv2.line(img_fallback_trendlines, (line_start_x, line_y), (line_end_x, line_y), (255, 255, 255), 1)
                        inst_position = (line_start_x, line_y + 15)
                        cv2.putText(img_fallback_trendlines, 'inst', inst_position, font, font_scale, text_color, thickness, line_type)
                        order_type = "instant sell"
                        print(f"Drew horizontal line at y={line_y} from x={line_start_x} to x={line_end_x} with 'inst' label for PH{arrow_number2}")
                        # Draw vertical line and determine labels
                        success, breakeven_status, stoploss_status, takeprofit_status, order_status = draw_first_matching_line(
                            line_end_x, line_y, sorted_positions, False, line_start_x, line_end_x, arrow_number2, 'PH'
                        )
                        if success:
                            print(f"Drew vertical lines at x={line_start_x} (left) and x={line_end_x} (right) from y={line_y} with labels for PH{arrow_number2}")
                        else:
                            # Override order_type based on no hits
                            order_type = order_status  # Use order_status from draw_first_matching_line
                            print(f"No hits, using order_status={order_type} from draw_first_matching_line for PH{arrow_number2}")
        
        # Create fallback trendline data entry with updated statuses
        fallback_trendline_entry = {
            "type": "PL-to-PH",
            "sender": {
                "candle_color": sender_color,
                "position_number": sender_pos_number
            },
            "receiver": {
                "candle_color": receiver_color,
                "position_number": receiver_pos_number,
                "order_type": order_type,
                "next_parent": second_next_parent_type if second_next_parent_x else "invalid",
                "receiver_arrow_number": arrow_number2,
                "Breakeven": breakeven_status,
                "Stoploss_status": stoploss_status,
                "Takeprofit": takeprofit_status,
                "order_status": order_status
            }
        }
        fallback_trendline_data.append(fallback_trendline_entry)
        
        # Add to instant_contracts if order_type is "instant sell"
        if order_type == "instant sell":
            instant_contracts.append(fallback_trendline_entry)
        
        used_points_pl_to_ph.add(label1)
        used_points_pl_to_ph.add(label2)
    
    # Sort fallback trendlines by sender position number (left to right)
    fallback_trendline_data.sort(key=lambda x: x['sender']['position_number'])
    
    # Select the number of fallback trendlines to draw (based on num_contracts, rightmost first)
    fallback_trendlines_to_draw = sorted(fallback_trendline_data, key=lambda x: x['receiver']['position_number'], reverse=True)[:num_contracts]
    print(f"Total valid fallback trendlines: {len(fallback_trendline_data)}, drawing {min(num_contracts, len(fallback_trendline_data))} fallback trendlines")
    
    # If num_contracts is 0, save the image with only position numbers
    if num_contracts == 0:
        print("Number of contracts set to 0, only position numbers drawn")
        for entry in fallback_trendline_data:
            entry['receiver']['Breakeven'] = "none"
            entry['receiver']['Stoploss_status'] = "none"
            entry['receiver']['Takeprofit'] = "none"
            entry['receiver']['order_status'] = "none"
        fallback_trendline_image_path = os.path.join(OUTPUT_FOLDER, "fallback.png")
        cv2.imwrite(fallback_trendline_image_path, img_fallback_trendlines)
        print(f"Parent fallback trendlines image saved to: {fallback_trendline_image_path}")
        # Save instant contracts to jsonback.json
        save_instant_contracts_to_json(instant_contracts)
        return fallback_trendline_image_path, fallback_trendline_data
    
    # Draw selected fallback trendlines and label CPs
    for fallback_trendline in fallback_trendlines_to_draw:
        sender_x = next((x for x, _, label, _ in (ph_labels if fallback_trendline['type'] == 'PH-to-PL' else pl_labels) if label == f"{fallback_trendline['type'].split('-')[0]}{fallback_trendline['sender']['position_number']}"), None)
        sender_y = next((y for x, y, label, _ in (ph_labels if fallback_trendline['type'] == 'PH-to-PL' else pl_labels) if label == f"{fallback_trendline['type'].split('-')[0]}{fallback_trendline['sender']['position_number']}"), None)
        receiver_x = next((x for x, _, label, _ in (pl_labels if fallback_trendline['type'] == 'PH-to-PL' else ph_labels) if label == f"{fallback_trendline['type'].split('-')[2]}{fallback_trendline['receiver']['receiver_arrow_number']}"), None)
        receiver_y = next((y for x, y, label, _ in (pl_labels if fallback_trendline['type'] == 'PH-to-PL' else ph_labels) if label == f"{fallback_trendline['type'].split('-')[2]}{fallback_trendline['receiver']['receiver_arrow_number']}"), None)
        
        if sender_x is None or sender_y is None or receiver_x is None or receiver_y is None:
            print(f"Skipping fallback trendline drawing for {fallback_trendline['type']} due to missing coordinates")
            continue
        
        receiver_candle, _ = get_candle_at_position(receiver_x, fallback_trendline_position)
        if receiver_candle is None:
            print(f"No candlestick found at position {fallback_trendline_position} for {fallback_trendline['type']}, skipping")
            continue
        
        start = (sender_x, sender_y)
        end = extend_line_to_right_edge(sender_x, sender_y, receiver_candle[0], receiver_candle[1 if fallback_trendline['type'] == 'PH-to-PL' else 2], img_width)
        color = (0, 255, 0) if fallback_trendline['type'] == 'PH-to-PL' else (0, 255, 255)
        cv2.line(img_fallback_trendlines, start, end, color, 2)
        
        cp_y = receiver_candle[1 if fallback_trendline['type'] == 'PH-to-PL' else 2]
        text_position = (receiver_candle[0] - 40 if fallback_trendline['type'] == 'PH-to-PL' else receiver_candle[0] - 30, cp_y)
        cv2.putText(img_fallback_trendlines, 'CP', text_position, cv2.FONT_HERSHEY_SIMPLEX,
                    0.5, (255, 255, 255), 1, cv2.LINE_AA)
        
        type_label = 'PH&PL' if fallback_trendline['type'] == 'PH-to-PL' else 'PL&PH'
        type_position = (text_position[0], text_position[1] + 15)
        cv2.putText(img_fallback_trendlines, type_label, type_position, cv2.FONT_HERSHEY_SIMPLEX,
                    0.4, (255, 255, 255), 1, cv2.LINE_AA)
        
        print(f"Connected {fallback_trendline['type']} from sender (pos={fallback_trendline['sender']['position_number']}, "
              f"color={fallback_trendline['sender']['candle_color']}) "
              f"to receiver (pos={fallback_trendline['receiver']['position_number']}, "
              f"color={fallback_trendline['receiver']['candle_color']}) "
              f"with {'green' if fallback_trendline['type'] == 'PH-to-PL' else 'yellow'} fallback trendline, "
              f"order_type={fallback_trendline['receiver']['order_type']}, "
              f"Breakeven={fallback_trendline['receiver']['Breakeven']}, "
              f"Stoploss_status={fallback_trendline['receiver']['Stoploss_status']}, "
              f"Takeprofit={fallback_trendline['receiver']['Takeprofit']}, "
              f"order_status={fallback_trendline['receiver']['order_status']}, "
              f"next parent: {fallback_trendline['receiver'].get('next_parent', 'invalid')}")
    
    # Save the fallback trendline image
    fallback_trendline_image_path = os.path.join(OUTPUT_FOLDER, "fallback.png")
    cv2.imwrite(fallback_trendline_image_path, img_fallback_trendlines)
    print(f"Parent fallback trendlines image saved to: {fallback_trendline_image_path}")
    
    # Save instant contracts to jsonback.json
    save_instant_contracts_to_json(instant_contracts)
    
    return fallback_trendline_image_path, fallback_trendline_data

def save_instant_contracts_to_json(instant_contracts):
    """
    Save the instant contract data (with 'inst' label) to a JSON file named jsonback.json in the OUTPUT_FOLDER.
    
    Args:
        instant_contracts (list): List of dictionaries containing instant contract details.
    
    Returns:
        str: Path to the saved JSON file.
    """
    json_path = os.path.join(OUTPUT_FOLDER, "fallback.json")
    try:
        with open(json_path, 'w') as f:
            json.dump(instant_contracts, f, indent=4)
        print(f"Instant contract data saved to: {json_path}")
    except Exception as e:
        print(f"Error saving instant contract data to JSON: {e}")
    return json_path

def latestfallback_trendline(switch):
    """
    Control whether to show or hide the last fallback_trendline when there is no parent ahead of the receiver.
    
    Args:
        switch (str): "show" to allow the last fallback_trendline, "hide" to restrict it.
    
    Returns:
        bool: True if the last fallback_trendline should be shown, False otherwise.
    """
    valid_options = ["show", "hide"]
    if switch.lower() not in valid_options:
        print(f"Invalid switch value '{switch}', defaulting to 'hide'")
        return False
    return switch.lower() == "show"

def fallback_trendlinecontracts(number):
    """
    Validate the number of contract points (CPs) and their associated fallback_trendlines to display.
    Starts from the rightmost (latest) fallback_trendline and selects sequentially leftward.
    
    Args:
        number (str): Number of contract points to display (e.g., "1", "2"). If "0", display none.
                     If greater than available fallback_trendlines, display all.
    
    Returns:
        int: Validated number of contract points to display, defaults to 0 if invalid.
    """
    try:
        num_contracts = int(number)
        if num_contracts < 0:
            print(f"Number of contracts {num_contracts} is negative, defaulting to 0")
            num_contracts = 0
        return num_contracts
    except ValueError:
        print(f"Invalid number of contracts {number}, defaulting to 0")
        return 0

def PHandPLfallback_trendlinedistancecontrol(distance):
    """
    Validate the distance threshold for fallback_trendlines between sender (PH/PL) and the target candlestick.
    
    Args:
        distance (str): The minimum vertical distance in pixels (e.g., "0", "10", "20", "50", "100", "200").
    
    Returns:
        int: Validated distance threshold, defaults to 0 if invalid or not in allowed values.
    """
    allowed_distances = [0, 10, 20, 50, 100, 200]
    try:
        dist = int(distance)
        if dist not in allowed_distances:
            print(f"Distance {dist} is not in allowed values {allowed_distances}, defaulting to 0")
            dist = 0
    except ValueError:
        print(f"Invalid distance {distance}, defaulting to 0")
        dist = 0
    
    return dist

def fallback_trendlinetocandleposition(position):
    """
    Validate the candlestick position to connect fallback_trendlines to (1 to 5).
    
    Args:
        position (str): The position of the candlestick to the right (1 to 5).
    
    Returns:
        str: Validated position as a string (1 to 5), defaults to "1" if invalid or out of range.
    """
    try:
        pos = int(position)
        if pos > 5 or pos < 1:
            print(f"Position {pos} is out of range (1-5), defaulting to 1")
            pos = 1
    except ValueError:
        print(f"Invalid position {position}, defaulting to 1")
        pos = 1
    
    return str(pos)


def main():
    """Main function to orchestrate image processing pipeline."""
    # Clear the base output folder before processing
    clear_output_folder()
    
    # Create market-specific output folder
    os.makedirs(OUTPUT_FOLDER, exist_ok=True)
    
    try:
        # MECHANISM CONTROLS
        #main
        left_required, right_required = controlleftandrighthighsandlows("1", "1")
        main_trendline_position = main_trendlinetocandleposition("2")
        distance_threshold = PHandPLmain_trendlinedistancecontrol("50")
        num_contracts = main_trendlinecontracts("100")
        allow_latest_main_trendline = latestmain_trendline("show")
        #fallback
        left_required, right_required = controlleftandrighthighsandlows("1", "1")
        fallback_trendline_position = fallback_trendlinetocandleposition("2")
        distance_threshold = PHandPLfallback_trendlinedistancecontrol("50")
        num_contracts = fallback_trendlinecontracts("100")
        allow_latest_fallback_trendline = latestfallback_trendline("show")

        # Load latest chart
        img, base_name = load_latest_chart()
        if img is None:
            return
        
        # Get image dimensions
        height, width = img.shape[:2]
        
        # Crop image
        img = crop_image(img, height, width)
        
        # Enhance colors
        img_enhanced, mask_red, mask_green, mask = enhance_colors(img)
        
        # Replace near-black wicks
        img_enhanced = replace_near_black_wicks(img_enhanced, mask_red, mask_green)
        
        # Sharpen image
        img_enhanced = sharpen_image(img_enhanced)
        
        # Set background to black
        img_enhanced = set_background_black(img_enhanced, mask)
        
        # Save enhanced image
        save_enhanced_image(img_enhanced, base_name)
        
        # Remove horizontal lines
        img_enhanced, mask_red, mask_green, mask = remove_horizontal_lines(img_enhanced, mask_red, mask_green, width)
        
        # Detect candlestick contours and collect arrow data
        img_contours, red_positions, green_positions, arrow_data = detect_candlestick_contours(img_enhanced, mask_red, mask_green)
        
        # Save contour image
        save_contour_image(img_contours, base_name)
        
        # Save arrow data to JSON
        save_arrow_data_to_json(arrow_data)
        
        # Construct all_positions from red_positions and green_positions
        all_positions = [(pos, 'red') for pos in red_positions] + [(pos, 'green') for pos in green_positions]
        all_positions.sort(key=lambda x: x[0][0])
        
        # Identify and label Parent Highs and Lows using enhanced image
        parent_labeled_image_path, pl_labels, ph_labels = identify_parent_highs_and_lows(
            img_enhanced, all_positions, base_name, left_required, right_required, arrow_data
        )
        img_parent_labeled = cv2.imread(parent_labeled_image_path)
        
        # Draw main_trendlines between Parent Highs and Lows and collect main_trendline data
        main_trendline_image_path, main_trendline_data = draw_parent_main_trendlines(
            img_parent_labeled, all_positions, base_name, left_required, right_required,
            main_trendline_position, distance_threshold, num_contracts, allow_latest_main_trendline,
            pl_labels, ph_labels
        )
        
        # Save main_trendline data to JSON
        save_main_trendline_data_to_json(main_trendline_data)

        # Draw fallback_trendlines between Parent Highs and Lows and collect fallback_trendline data
        fallback_trendline_image_path, fallback_trendline_data = draw_parent_fallback_trendlines(
            img_parent_labeled, all_positions, base_name, left_required, right_required,
            fallback_trendline_position, distance_threshold, num_contracts, allow_latest_fallback_trendline,
            pl_labels, ph_labels
        )
        
        
        print("Candlestick contour processing, parent highs/lows labeling, main_trendline drawing, and JSON data saving complete.")
        
    except Exception as e:
        print(f"Error processing image: {e}")

if __name__ == "__main__":
    main()
    
